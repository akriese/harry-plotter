# %% [esm]
import * as tj from "https://cdn.skypack.dev/pin/topojson@v3.0.2-ovpHjX420lx9YlKkg1QF/mode=imports/optimized/topojson.js"
import * as d3_ from "https://cdn.skypack.dev/d3@7"
import * as d3S from 'https://cdn.skypack.dev/d3-simple-slider';
export const topojson = tj;
export const d3 = d3_;
export const d3SimpleSlider = d3S;
# %% [markdown]
# Harry Plotter - First Design Sprint
# %% [markdown]
## Load data

* load cleaned cultural facility json data
* load locations
* change format
* prepare data for plotting

\

# %% [javascript]
const response = await fetch("https://raw.githubusercontent.com/akriese/harry-plotter/main/data/data.json")
var data = await response.json();
console.log(data)
# %% [javascript]
const response = await fetch("https://raw.githubusercontent.com/akriese/harry-plotter/main/data/locations.json")
var loc_data = await response.json();
console.log(loc_data)
# %% [javascript]
var new_data = {}
for (const [idx, d] of data.entries()) {
  var inst = d.Institution
  //console.log(inst)
  if (!(inst in new_data)) {
    loc = loc_data.find(l => l.Institution === inst)
    //console.log(loc)
    new_data[inst] = {
      Kategorie: d.Kategorie,
      Latitude: loc.Latitude,
      Longitude: loc.Longitude,
      zahlen: [[d.Jahr, Math.max(1, d["Besuche insgesamt"])]]
    }
  } else {
    new_data[inst].zahlen.push([d.Jahr, Math.max(1, d["Besuche insgesamt"])])
  }
}

// fill missing years from 2011
for (const [inst, values] of Object.entries(new_data)) {
  if (values.zahlen.length == 4) continue;
  for (let i=0; i<4; i++) {
    if (values.zahlen.find(([y, b]) => y == i+2011) === undefined) {
      values.zahlen.push([i+2011, 1]) // year data not in zahlen array, add year with 0 visitors
    }
  }
  values.zahlen.sort((tup1, tup2) => tup1[0] > tup2[0]) // sort new entries by year numbers
}
console.log(new_data)
# %% [javascript]
var plot_data = [];
for (const [inst, values] of Object.entries(new_data)){
  for(j in values.zahlen){
    if(values.zahlen[j][1] == '-' || values.zahlen[j][1] == 'geschlossen'){
      values.zahlen[j][1] = 1;
    }
  }
  var entry = [new_data[i].Kategorie, new_data[i].Longitude, new_data[i].Latitude, new_data[i].zahlen];
  plot_data.push(entry);
}
console.log(plot_data)
# %% [markdown]
## Define plot function
# %% [javascript]
// Copyright 2022 Observable, Inc.
// Released under the ISC license.
// https://observablehq.com/@d3/bubble-map
function BubbleMap(data, {
  position = d => d, // given d in data, returns the [longitude, latitude]
  value = () => undefined, // given d in data, returns the quantitative value
  cat = () => undefined,
  title, // given a datum d, returns the hover text
  scale = d3.scaleLog, // type of radius scale
  domain, // [0, max] values; input of radius scale; must start at zero
  maxRadius = 20, // maximum radius of bubbles
  width = 640, // outer width, in pixels
  height, // outer height, in pixels
  projection, // a D3 projection; null for pre-projected geometry
  features, // a GeoJSON feature collection for the background
  borders, // a GeoJSON object for stroking borders
  outline = projection && projection.rotate ? {type: "Sphere"} : null, // a GeoJSON object for the background
  backgroundFill = "#e0e0e0", // fill color for background
  backgroundStroke = "white", // stroke color for borders
  backgroundStrokeWidth, // stroke width for borders
  backgroundStrokeOpacity, // stroke width for borders
  backgroundStrokeLinecap = "round", // stroke line cap for borders
  backgroundStrokeLinejoin = "round", // stroke line join for borders
  //fill = d => d,// = "brown", // fill color for bubbles
  fillOpacity = 0.5, // fill opacity for bubbles
  stroke = "white", // stroke color for bubbles
  strokeWidth = 0.5, // stroke width for bubbles
  strokeOpacity, // stroke opacity for bubbles
  legendX = width - maxRadius - 10,
  legendY = height - 10,
} = {}) {
  // Compute values.
  const I = d3.map(data, (_, i) => i);
  const V = d3.map(data, value).map(d => d == null ? NaN : +d);
  const P = d3.map(data, position);
  const T = title == null ? null : d3.map(data, title);
  var color = d3.scaleOrdinal(data.map(d => d[0]), d3.schemeCategory10).unknown("red");
  const col = d3.map(data, (d) => color(d[0]));

  // Compute default domains.
  if (domain === undefined) domain = [1000, 100000];

  // Construct scales.
  const radius = scale(domain, [1, maxRadius]);

  // Compute the default height. If an outline object is specified, scale the projection to fit
  // the width, and then compute the corresponding height.
  if (height === undefined) {
    if (outline === undefined) {
      height = 400;
    } else {
      const [[x0, y0], [x1, y1]] = d3.geoPath(projection.fitWidth(width, outline)).bounds(outline);
      const dy = Math.ceil(y1 - y0), l = Math.min(Math.ceil(x1 - x0), dy);
      projection.scale(projection.scale() * (l - 1) / l).precision(0.2);
      height = dy;
    }
  }

  function reset() {
    states.transition().style("fill", null);
    svg.transition().duration(750).call(
      zoom.transform,
      d3.zoomIdentity,
      d3.zoomTransform(svg.node()).invert([width / 2, height / 2])
    );
  }

  function clicked(event, d) {
    const [[x0, y0], [x1, y1]] = path.bounds(d);
    event.stopPropagation();
    states.transition().style("fill", null);
    d3.select(this).transition().style("fill", "red");
    svg.transition().duration(750).call(
      zoom.transform,
      d3.zoomIdentity
        .translate(width / 2, height / 2)
        .scale(Math.min(8, 0.9 / Math.max((x1 - x0) / width, (y1 - y0) / height)))
        .translate(-(x0 + x1) / 2, -(y0 + y1) / 2),
      d3.pointer(event, svg.node())
    );
  }

  function zoomed(event) {
    const {transform} = event;
    g.attr("transform", transform);
    g.attr("stroke-width", 1 / transform.k);
  }

  const zoom = d3.zoom()
      .scaleExtent([1, 8])
      .on("zoom", zoomed);

  // Construct a path generator.
  const path = d3.geoPath(projection);

  const svg = d3.select("#content").append("svg")
      .attr("width", width)
      .attr("height", height)
      .attr("viewBox", [0, 0, width, height])
      .attr("style", "width: 100%; height: auto; height: intrinsic;")
      .on("click", reset);

  if (outline != null) svg.append("path")
      .attr("fill", "white")
      .attr("stroke", "currentColor")
      .attr("d", path(outline));

  const g = svg.append("g");
  const states = g.append("g")
      .attr("fill", backgroundFill)
      .attr("cursor", "pointer")
    .selectAll("path")
    .data(topojson.feature(berlin_topo, berlin_topo.objects.states).features)
    .join("path")
      .on("click", clicked)
      .attr("d", path);

  states.append("title")
      .text(d => d.properties.name);

  if (borders != null) g.append("path")
      .attr("pointer-events", "none")
      .attr("fill", "none")
      .attr("stroke", backgroundStroke)
      .attr("stroke-linecap", backgroundStrokeLinecap)
      .attr("stroke-linejoin", backgroundStrokeLinejoin)
      .attr("stroke-width", backgroundStrokeWidth)
      .attr("stroke-opacity", backgroundStrokeOpacity)
      .attr("d", path(borders));

  const legend = svg.append("g")
      .attr("fill", "#777")
      .attr("transform", `translate(${legendX},${legendY})`)
      .attr("text-anchor", "middle")
      .style("font", "10px sans-serif")
    .selectAll("g")
      .data(radius.ticks(4).slice(1))
    .join("g");

  legend.append("circle")
      .attr("fill", "none")
      .attr("stroke", "#ccc")
      .attr("cy", d => -radius(d))
      .attr("r", radius);

  legend.append("text")
      .attr("y", d => -2 * radius(d))
      .attr("dy", "1.3em")
      .text(radius.tickFormat(4, "s"));

  function bubbleClicked(event, d) {
    console.log(event, d)
  }

  const bubbles = g.append("g")
      .attr("fill-opacity", fillOpacity)
      .attr("stroke", stroke)
      .attr("stroke-width", strokeWidth)
      .attr("stroke-opacity", strokeOpacity)
      .attr("cursor", "pointer")
      .selectAll("circle")
      .data(d3.range(data.length)
        .filter(i => P[i])
        .sort((i, j) => d3.descending(V[i], V[j])))
      .join("circle")
      .attr("transform", projection == null
        ? i => `translate(${P[i]})`
        : i => `translate(${projection(P[i])})`)
      .attr("r", i => radius(V[i]))
      .attr("fill", i => col[i])
      .attr("stroke", i => col[i])
      .call(T ? circle => circle.append("title").text(i => T[i]) : () => {})
      .join("path")
      .on("clicked", bubbleClicked)
      .attr("d", path);

  svg.call(zoom);

  return Object.assign(svg.node(), {scales: {radius}});
}
# %% [javascript]
// fetched from https://raw.githubusercontent.com/m-hoerz/berlin-shapes/master/berliner-bezirke.geojson
// equivalent to bubblemap nation
var districts_features = await fetch("https://raw.githubusercontent.com/funkeinteraktiv/Berlin-Geodaten/master/berlin_bezirke.geojson").then(resp => resp.json())
console.log(districts_features)
# %% [javascript]
var berlin_topo = await fetch("https://raw.githubusercontent.com/funkeinteraktiv/Berlin-Geodaten/master/berlin_bezirke.topojson").then(response => response.json())
berlin_topo
# %% [javascript]
var berlin = {
  type: "FeatureCollection",
  features: [
    {
      type: "Feature",
      properties: {},
      geometry: topojson.merge(berlin_topo, berlin_topo.objects.states.geometries)
    }
  ]
}
berlin
# %% [javascript]
// statemesh should work as it looks like in the bubble map example
statemesh = topojson.mesh(berlin_topo, berlin_topo.objects.states, (a, b) => a !== b)
# %% [html]

<div id="content"></div>
<link
  rel="stylesheet"
  href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css"
  integrity="sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO"
  crossorigin="anonymous"
/>
<div class="row align-items-center">
  <div class="col-sm-2"><p id="value-time"></p></div>
  <div class="col-sm"><div id="slider-time"></div></div>
</div>
# %% [css]
body {
  font-family: "Helvetica Neue", Helvetica, sans-serif;
  font-size: 14px;
  color: #333;
}
# %% [javascript]
let [min, max] = [2011, 2014]
var dataTime = d3.range(min, max+1)

function drawChartWithYear(yearMapper) {
  var chart = BubbleMap(plot_data, {
    value: yearMapper,
    cat: ([category, , , ]) => category,
    position([, Longitude, Latitude, ]){
      return [Longitude, Latitude];
    },
    //title([, , , zahlen]) {
    //  return `${zahlen}`;
    //},
    //fill([category, , , ]){
    //  return color(category);
    //},
    features: districts_features,
    borders: statemesh,
    projection: d3.geoMercator().fitExtent([[-100, 180],[800, 500]], statemesh),
    width: 800,
    height: 600
  })
  console.log(chart);
}

function redrawChartWithYear(year) {
  function yearMapper([, , , zahlen]) {
    return zahlen.find((ls) => year == ls[0])[1]
  }

  let contentDiv = document.getElementById("content");
  let svgDiv = contentDiv.lastElementChild
  if (svgDiv !== null) {
    contentDiv.removeChild(svgDiv)
  }

  drawChartWithYear(yearMapper);
}

// remove old slider on reload
let sliderDiv = document.getElementById("slider-time");
let sliderSvg = sliderDiv.lastElementChild
while (sliderSvg !== null) {
  sliderDiv.removeChild(sliderSvg)
  sliderSvg = sliderDiv.lastElementChild
}

var sliderTime = d3SimpleSlider
  .sliderBottom()
  .min(min)
  .max(max)
  .step(1)
  .width(300)
  .tickFormat(d3.format('d'))
  .tickValues(dataTime)
  .default(min)
  .on('onchange', val => {
    redrawChartWithYear(val)
  });

var gTime = d3
  .select('div#slider-time')
  .append('svg')
  .attr('width', 500)
  .attr('height', 100)
  .append('g')
  .attr('transform', 'translate(30,30)');

gTime.call(sliderTime);

d3.select('p#value-time').text(sliderTime.value());
