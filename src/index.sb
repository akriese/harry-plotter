# %% [javascript]
await import("https://cdnjs.cloudflare.com/ajax/libs/d3/7.6.1/d3.min.js")
await import("https://cdnjs.cloudflare.com/ajax/libs/topojson/3.0.2/topojson.js")
# %% [markdown]
# Harry Plotter - First Design Sprint
# %% [markdown]
## Load data

* load cleaned cultural facility json data
* load locations
* change format
* prepare data for plotting

\

# %% [javascript]
const response = await fetch("https://raw.githubusercontent.com/akriese/harry-plotter/main/data/data.json")
var data = await response.json();
console.log(data)
# %% [javascript]
const response = await fetch("https://raw.githubusercontent.com/akriese/harry-plotter/main/data/locations.json")
var loc_data = await response.json();
console.log(loc_data)
# %% [javascript]
var new_data = {}
for (const [idx, d] of data.entries()) {
  var inst = d.Institution
  //console.log(inst)
  if (!(inst in new_data)) {
    loc = loc_data.find(l => l.Institution === inst)
    //console.log(loc)
    new_data[inst] = {
      Kategorie: d.Kategorie,
      Latitude: loc.Latitude,
      Longitude: loc.Longitude,
      zahlen: [[d.Jahr, d["Besuche insgesamt"]]]
    }
  } else {
    new_data[inst].zahlen.push([d.Jahr, d["Besuche insgesamt"]])
  }
}
console.log(new_data)
# %% [javascript]
var plot_data = [];
for (i in new_data){
  for(j in new_data[i].zahlen){
    if(new_data[i].zahlen[j][1] == '-' || new_data[i].zahlen[j][1] == 'geschlossen'){
      new_data[i].zahlen[j][1] = 0;
    }
  }
  var entry = [new_data[i].Kategorie, new_data[i].Latitude, new_data[i].Longitude, new_data[i].zahlen];
  plot_data.push(entry);
}
console.log(plot_data)
# %% [markdown]
## Define plot function
# %% [javascript]
// Copyright 2022 Observable, Inc.
// Released under the ISC license.
// https://observablehq.com/@d3/bubble-map
function BubbleMap(data, {
  position = d => d, // given d in data, returns the [longitude, latitude]
  value = () => undefined, // given d in data, returns the quantitative value
  title, // given a datum d, returns the hover text
  scale = d3.scaleSqrt, // type of radius scale
  domain, // [0, max] values; input of radius scale; must start at zero
  maxRadius = 40, // maximum radius of bubbles
  width = 640, // outer width, in pixels
  height, // outer height, in pixels
  projection, // a D3 projection; null for pre-projected geometry
  features, // a GeoJSON feature collection for the background
  borders, // a GeoJSON object for stroking borders
  outline = projection && projection.rotate ? {type: "Sphere"} : null, // a GeoJSON object for the background
  backgroundFill = "#e0e0e0", // fill color for background
  backgroundStroke = "white", // stroke color for borders
  backgroundStrokeWidth, // stroke width for borders
  backgroundStrokeOpacity, // stroke width for borders
  backgroundStrokeLinecap = "round", // stroke line cap for borders
  backgroundStrokeLinejoin = "round", // stroke line join for borders
  fill = "brown", // fill color for bubbles
  fillOpacity = 0.5, // fill opacity for bubbles
  stroke = "white", // stroke color for bubbles
  strokeWidth = 0.5, // stroke width for bubbles
  strokeOpacity, // stroke opacity for bubbles
  legendX = width - maxRadius - 10,
  legendY = height - 10,
} = {}) {
  // Compute values.
  const I = d3.map(data, (_, i) => i);
  const V = d3.map(data, value).map(d => d == null ? NaN : +d);
  const P = d3.map(data, position);
  const T = title == null ? null : d3.map(data, title);

  // Compute default domains.
  if (domain === undefined) domain = [0, d3.max(V)];

  // Construct scales.
  const radius = scale(domain, [0, maxRadius]);

  // Compute the default height. If an outline object is specified, scale the projection to fit
  // the width, and then compute the corresponding height.
  if (height === undefined) {
    if (outline === undefined) {
      height = 400;
    } else {
      const [[x0, y0], [x1, y1]] = d3.geoPath(projection.fitWidth(width, outline)).bounds(outline);
      const dy = Math.ceil(y1 - y0), l = Math.min(Math.ceil(x1 - x0), dy);
      projection.scale(projection.scale() * (l - 1) / l).precision(0.2);
      height = dy;
    }
  }

  // Construct a path generator.
  const path = d3.geoPath(projection);

  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height)
      .attr("viewBox", [0, 0, width, height])
      .attr("style", "width: 100%; height: auto; height: intrinsic;");

  if (outline != null) svg.append("path")
      .attr("fill", "white")
      .attr("stroke", "currentColor")
      .attr("d", path(outline));

  svg.append("path")
      .datum(features)
      .attr("fill", backgroundFill)
      .attr("d", path);

  if (borders != null) svg.append("path")
      .attr("pointer-events", "none")
      .attr("fill", "none")
      .attr("stroke", backgroundStroke)
      .attr("stroke-linecap", backgroundStrokeLinecap)
      .attr("stroke-linejoin", backgroundStrokeLinejoin)
      .attr("stroke-width", backgroundStrokeWidth)
      .attr("stroke-opacity", backgroundStrokeOpacity)
      .attr("d", path(borders));

  const legend = svg.append("g")
      .attr("fill", "#777")
      .attr("transform", `translate(${legendX},${legendY})`)
      .attr("text-anchor", "middle")
      .style("font", "10px sans-serif")
    .selectAll("g")
      .data(radius.ticks(4).slice(1))
    .join("g");

  legend.append("circle")
      .attr("fill", "none")
      .attr("stroke", "#ccc")
      .attr("cy", d => -radius(d))
      .attr("r", radius);

  legend.append("text")
      .attr("y", d => -2 * radius(d))
      .attr("dy", "1.3em")
      .text(radius.tickFormat(4, "s"));

  svg.append("g")
      .attr("fill", fill)
      .attr("fill-opacity", fillOpacity)
      .attr("stroke", stroke)
      .attr("stroke-width", strokeWidth)
      .attr("stroke-opacity", strokeOpacity)
    .selectAll("circle")
    .data(d3.range(data.length)
        .filter(i => P[i])
        .sort((i, j) => d3.descending(V[i], V[j])))
    .join("circle")
      .attr("transform", projection == null
          ? i => `translate(${P[i]})`
          : i => `translate(${projection(P[i])})`)
      .attr("r", i => radius(V[i]))
      .call(T ? circle => circle.append("title").text(i => T[i]) : () => {});

  return Object.assign(svg.node(), {scales: {radius}});
}
# %% [javascript]
// fetched from https://raw.githubusercontent.com/m-hoerz/berlin-shapes/master/berliner-bezirke.geojson
// equivalent to bubblemap nation
var berlin_geo = await fetch("https://raw.githubusercontent.com/m-hoerz/berlin-shapes/master/berliner-bezirke.geojson").then(response => response.json());
# %% [javascript]
var berlin_topo = await fetch("https://raw.githubusercontent.com/funkeinteraktiv/Berlin-Geodaten/master/berlin_bezirke.topojson").then(response => response.json())
berlin_topo
# %% [javascript]
berlin_topo.objects.states
# %% [javascript]
// copied from https://cdnjs.cloudflare.com/ajax/libs/topojson/3.0.2/topojson.js
// TODO: fix import
var mesh = function(topology) {
  return object(topology, meshArcs.apply(this, arguments));
};

function meshArcs(topology, object$$1, filter) {
  var arcs, i, n;
  if (arguments.length > 1) arcs = extractArcs(topology, object$$1, filter);
  else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;
  return {type: "MultiLineString", arcs: stitch(topology, arcs)};
}

function extractArcs(topology, object$$1, filter) {
  var arcs = [],
      geomsByArc = [],
      geom;

  function extract0(i) {
    var j = i < 0 ? ~i : i;
    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});
  }

  function extract1(arcs) {
    arcs.forEach(extract0);
  }

  function extract2(arcs) {
    arcs.forEach(extract1);
  }

  function extract3(arcs) {
    arcs.forEach(extract2);
  }
  
  function geometry(o) {
    switch (geom = o, o.type) {
      case "GeometryCollection": o.geometries.forEach(geometry); break;
      case "LineString": extract1(o.arcs); break;
      case "MultiLineString": case "Polygon": extract2(o.arcs); break;
      case "MultiPolygon": extract3(o.arcs); break;
    }
  }

  geometry(object$$1);

  geomsByArc.forEach(filter == null
      ? function(geoms) { arcs.push(geoms[0].i); }
      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });

  return arcs;
}
# %% [javascript]
// import error from topojson
statemesh = mesh(berlin_geo, berlin_topo.objects.states, (a, b) => a !== b)
# %% [javascript]
var chart = BubbleMap(plot_data, { 
  value: ([, , , zahlen]) => zahlen[0][1],
  position([, Longitude, Latitude, ]){
    return Longitude, Latitude;
  },
  //title([, , , zahlen]) {
  //  return `${zahlen}`;
  //},
  features: berlin_geo,
  //borders: statemesh, //get statemesh
  width: 975,
  height: 610
})
chart
