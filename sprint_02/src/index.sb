# %% [esm]
import * as tj from "https://cdn.skypack.dev/pin/topojson@v3.0.2-ovpHjX420lx9YlKkg1QF/mode=imports/optimized/topojson.js"
import * as d3_ from "https://cdn.skypack.dev/d3@7.6.0"
import proj from 'https://cdn.skypack.dev/proj4'
import leaflet from 'https://cdn.skypack.dev/leaflet'
import leafletMarkercluster from 'https://cdn.skypack.dev/leaflet.markercluster';
export const topojson = tj;
export const d3 = d3_;
export const proj4 = proj;
export const L = leaflet;
export const Lm = leafletMarkercluster;
# %% [javascript]
async function fetchJson(url) {
  return fetch(url).then(response => response.json())
}

// LINREF coordinates in "ETRS89 / UTM zone 32N" (https://epsg.io/25832-1149)
var data = await fetchJson("https://raw.githubusercontent.com/akriese/harry-plotter/main/sprint_02/data/data_2021.json")

// district features https://tsb-opendata.s3.eu-central-1.amazonaws.com/lor_bezirksregionen_2021/lor_bezirksregionen_2021.geojson
// coordinates in "WGS 84 / UTM zone 33N" (https://epsg.io/32633)
// says https://www.stadtentwicklung.berlin.de/planen/basisdaten_stadtentwicklung/lor/de/download.shtml
var berlin_lor_topo = await fetchJson("https://raw.githubusercontent.com/akriese/harry-plotter/main/sprint_02/data/lor_bezirksregionen_2021.topojson")
berlin_lor_topo

# %% [javascript]
/// We define the two different coordinate systems for proj4
proj4.defs([["EPSG:32632","+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs +type=crs"],
           ["EPSG:32633", "+proj=utm +zone=33 +datum=WGS84 +units=m +no_defs +type=crs"],
           ["WGS84","+proj=longlat +datum=WGS84 +no_defs +type=crs"]]);
function from32to33(coords) {
  return proj4("EPSG:32632", "EPSG:32633", coords)
}

// ... and assign each data point a new parameter 'coords' holding x AND y value
// these coordinates now match the coordinates that are used by the topojson file :)
for (i in data) {
  data[i].coords = from32to33([data[i].LINREFX, data[i].LINREFY])
}
# %% [javascript]
// Precompute list of involved per accident
for (i in data) {
  var arr = []
  for (const [key, value] of Object.entries(data[i])) {
    if (key.startsWith("Ist") && value === true) {
      arr.push(key.replace("Ist", ""))
    }
  }
  data[i].Beteiligte = arr
}

# %% [javascript]
data[1]
# %% [javascript]
/// Collection of functions that grab certain parts of the given data

// general function to count occurences of a category in one data property
// property: name of the property to count in
// categories: list of categories whose counts in property get returned
function countCategoryOccurences(data, property, categories) {
  var counter = {}
  for (c of categories) {
    counter[c] = 0
  }

  const propArr = data.map(accident => accident[property])
  for (p of propArr) {
    counter[p]++
  }

  return counter
}

// count graveness
function countGraveness(data) {
  return countCategoryOccurences(data, "UKATEGORIE", [1, 2, 3])
}

// count accident types
function countAccidentTypes(data) {
  return countCategoryOccurences(data, "UTYP1", [1, 2, 3, 4, 5, 6, 7])
}

// extract accident time data
// mode: one of {"single", "array", "day_arrays"} defines how the data is returned
function getDaysAndHours(data, mode="single") {
  var filtered = data.map(accident => ({ day: accident.UWOCHENTAG, hour: accident.STUNDE }));
  if (mode === "single") return filtered;
  if (mode === "array" ) {
    return {
      day: filtered.map(acc => acc.day),
      hour: filtered.map(acc => acc.hour),
    }
  }

  // else: day_arrays
  var result = {}
  for (day of [1,2,3,4,5,6,7]) {
    result[day] = []
  }

  for (p of filtered) {
    result[p.day].push(p.hour)
  }

  return result
}

// get numbers of how many accidents had e.g. cars involved
function getInvolvedNumbers(data) {
  var involved = ["IstRad", "IstPkw", "IstFuss", "IstKrad", "IstGkfz", "IstSonstige"]
  var results = {}
  for (x of involved) {
    results[x] = 0
  }

  for (accident of data) {
    for (x of involved) {
      results[x] += accident[x] ? 1 : 0
    }
  }

  return results
}
# %% [javascript]
/// Apply a filter on the overall data and return the chosen set
function filterData(data, {
  lor = undefined, // int describing the focused lor; undefined means the whole city is focused
  days = [], // list of ints, representing week days of chosen accidents; empty list means no filter
  graveness = undefined, // int describing the chosen accidents with certain graveness (1,2,3); undefined means no filter
  involved = [] // list of strings, which kind parties are involved in an accident; empty means no filter
}) {
  return data.filter(
    accident => {
      if (lor !== undefined && accident.lor !== lor) {
        return false
      }

      if (days.length != 0 && days.indexOf(accident.UWOCHENTAG) == -1) {
        return false
      }

      if (graveness !== undefined && accident.UKATEGORIE != graveness) {
        return false
      }

      if (involved.length != 0) {
        var skip = false
        for (inv of involved) {
          if (!accident[inv]) {
            skip = true
            break
          }
        }

        // if some required entity is not involved, we continue
        if (skip) {
          return false
        }
      }

      return true
    }
  );
}
# %% [javascript]
// trying out the filter function
function measureFiltering(filter) {
  console.time()
  var result = filterData(data, filter)
  console.timeEnd()
  console.log(result.length)
  return result
}

measureFiltering({ graveness: 1 })
measureFiltering({ graveness: 2, involved: ["IstRad", "IstKrad"] })
measureFiltering({ graveness: 2, involved: ["IstRad"], days: [1,2,5,6] })
measureFiltering({ graveness: 2, days: [1,2,5,6] })
getInvolvedNumbers(measureFiltering({ graveness: 1, involved: ["IstRad"], days: [1,2,5,6] }))
getDaysAndHours(data, mode="day_arrays")
# %% [javascript]
// Berlin topographies
var LorAreas = topojson.feature(berlin_lor_topo, berlin_lor_topo.objects.states)

// creating an LOR topo object with WGS84 as coordinate system
var LorWGS = { type: "FeatureCollection"}
LorWGS.features = LorAreas.features.map(feature => ({
  type: "Feature",
  properties: feature.properties,
  geometry: {
    type: "Polygon",
    coordinates: [feature.geometry.coordinates[0].map(coords => {
      const [x, y] = proj4("EPSG:32633", "WGS84", coords)
      return [y, x];
    })]
  }
}))

// TODO: probably not needed anymore since we are now using leaflets polygon function
// statemesh should work as it looks like in the bubble map example
//statemesh = topojson.mesh(berlin_lor_topo, berlin_lor_topo.objects.states, (a, b) => a !== b)

var projection = d3.geoIdentity()
  .reflectY(true)
  .fitSize([1500, 1000], topojson.feature(berlin_lor_topo, berlin_lor_topo.objects.states))
# %% [html]
<!-- Main div for the map svg -->
<div id="content"></div>

<body>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=" crossorigin="" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
  <div id=mother></div>
</body>
# %%--- [css]
# properties:
#   top_hidden: true
# ---%%
body {
  font-family: "Helvetica Neue", Helvetica, sans-serif;
  font-size: 14px;
  color: #333;
}

#mother {
  height: 850px;
  width: 1000px
}

.leaflet-container .leaflet-marker-pane img, .leaflet-container .leaflet-shadow-pane img {
  background-color: #fff0;
}

.leaflet-popup-content h2 {
  font-size: 20px;
  text-decoration: underline;
}

div.tooltip {
  position: absolute;
  text-align: center;
  width: fit-content;
  height: fit-content;
  padding: 2px;
  font: 12px sans-serif;
  background: lightsteelblue;
  border: 0px;
  border-radius: 8px;
  pointer-events: none;
}

/* Style of category legend text and circles */
.legend text {
  font-size: 0.8em;
  fill: black;
  font-family: sans-serif;
}

.legend circle {
  stroke: black;
  stroke-opacity: 0.5;
}
# %%--- [javascript]
# properties:
#   top_hidden: true
# ---%%
colorLegend = (selection, props) => {
  const {
    colorScale,
    circleRadius,
    spacing,
    textOffset,
    backgroundRectWidth
  } = props;

  const backgroundRect = selection.selectAll('rect')
    .data([null]);
  const n = colorScale.domain().length;
  backgroundRect.enter().append('rect')
    .merge(backgroundRect)
      .attr('x', -circleRadius * 2)
      .attr('y', -circleRadius * 2)
      .attr('rx', circleRadius * 2)
      .attr('width', backgroundRectWidth)
      .attr('height', spacing * n + circleRadius * 2)
      .attr('fill', 'white')
      .attr('opacity', 0.8);

  const groups = selection.selectAll('.legend')
    .data(colorScale.domain());
  const groupsEnter = groups
    .enter().append('g')
      .attr('class', 'legend')
      .attr('category', d => d)
      .style("opacity", 0.8);
  groupsEnter
    .merge(groups)
      .attr('transform', (d, i) =>
        `translate(0, ${i * spacing})`
      )
      .attr("cursor", "pointer");
  groups.exit().remove();

  groupsEnter.append('circle')
    .merge(groups.select('circle'))
      .attr('r', circleRadius)
      .attr('fill', colorScale);

  groupsEnter.append('text')
    .merge(groups.select('text'))
      // cut off long category names
      .text(d => d.length > 29 ? d.substr(0, 27) + '...' : d)
      .attr('dy', '0.32em')
      .attr('x', textOffset);
}
# %% [javascript]
function makeTooltipContent(accident) {
  const info = accident
  const persons = "<b>Beteiligte:</b> " + info.Beteiligte.join(", ")
  const dateTime = "<b>Monat:</b> " + info.UMONAT + "; <b>Wochentag:</b> " + info.UWOCHENTAG + "; <b>Stunde:</b> " + info.USTUNDE;
  const gs = ["Tödlich", "Schwer", "Leicht"]
  const graveness = "<b>Schweregrad:</b> " + gs[info.UKATEGORIE - 1]
  const accidentTypes = ["Fahrunfall", "Abbiegeunfall", "Einbiegen / Kreuzen-Unfall",
                        "Überschreiten-Unfall", "Unfall durch ruhenden Verkehr",
                        "Unfall im Längsverkehr", "Sonstiger Unfall"]

    return "<b>" + accidentTypes[info.UTYP1 - 1] + "</b><br>"
               + dateTime + "<br>"
               + persons + "<br>"
               + graveness + "<br>";
}
# %% [javascript]
function LeafletAccidentMap(data, {
  topo,
  topoCoordSystem = "EPSG:32633",
  divName = "mother",
  minZoom = 11,
  maxZoom = 19,
  states,
  stateTitle,
  tooltipContent,
  dotCoords,
}) {
  // get topo bounds and convert them to WGS84, but with LatLong format (x and y switched)
  var bounds = topojson.bbox(topo)
  var boundsArr = [bounds.slice(0, 2), bounds.slice(2, 4)]
  var projBounds = [proj4(topoCoordSystem, "WGS84", boundsArr[0]).reverse(),
                    proj4(topoCoordSystem, "WGS84", boundsArr[1]).reverse()]

  const mod = { initBounds: projBounds }

  // draw map
  mod.map = L.map(divName).fitBounds(projBounds);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    minZoom: minZoom,
    maxZoom: maxZoom,
  }).addTo(mod.map);

  // LOR polygons
  mod.states = states.features.map(f =>
    L.polygon(f.geometry.coordinates[0])
      .bindTooltip(stateTitle(f))
      .addTo(mod.map)
  );

  mod.markersCluster = undefined
  mod.update = function(data) {
    // TODO: update polygon colors

    // remove marker cluster layer if existent
    if (this.markersCluster !== undefined) {
      this.map.removeLayer(this.markersCluster)
      delete this.markersCluster
    }

    // set accidentMarkers
    this.markersCluster = L.markerClusterGroup({ showCoverageOnHover: false });

    data.forEach(d => {
      const dot = L
        .marker(dotCoords(d).reverse())
        .bindTooltip(tooltipContent(d))
      this.markersCluster.addLayer(dot)
    })

    this.map.addLayer(this.markersCluster);

    return this
  }

  mod.update(data)

  return mod;

  // Create dots with d3
  /*
  L.svg({clickable:true}).addTo(map)
  var [dots, P] = AccidentMap(data, {
    borders: statemesh,
    getCoordinates: d => ([d.XGCSWGS84, d.YGCSWGS84]),
    projection: d3.geoMercator(),
    topo: berlin_lor_topo,
    width: 1500,
    height: 1000,
    map: map
    //overlay: d3.select(map.getPanes().overlayPane).select('svg').attr("pointer-events", "auto")
  })
  */
}
# %% [javascript]
var module = LeafletAccidentMap(data, {
  topo: berlin_lor_topo,
  states: LorWGS,
  dotCoords: d => ([d.XGCSWGS84, d.YGCSWGS84]),
  tooltipContent: acc => makeTooltipContent(acc),
  stateTitle: f => f.properties.BZR_NAME,
})

// try out update, only show weekend accidents
//module.update(filterData(data, { days: [1,7] }))
# %% [javascript]
// Uncomment and execute to be able to reload the map
//module.map.remove()
# %% [javascript]
function removeAllChildren(name) {
  const div = document.getElementById(name);
  let child = div.lastElementChild;
  while (child !== null) {
    div.removeChild(child);
    child = div.lastElementChild;
  }
}
