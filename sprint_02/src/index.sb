# %%--- [esm]
# properties:
#   top_hidden: true
#   bottom_hidden: true
#   run_on_load: true
# ---%%
import * as tj from "https://cdn.skypack.dev/pin/topojson@v3.0.2-ovpHjX420lx9YlKkg1QF/mode=imports/optimized/topojson.js"
import * as d3_ from "https://cdn.skypack.dev/d3@7.6.0"
import proj from 'https://cdn.skypack.dev/proj4'
import leaflet from 'https://cdn.skypack.dev/leaflet'
import leafletMarkercluster from 'https://cdn.skypack.dev/leaflet.markercluster';
export const topojson = tj;
export const d3 = d3_;
export const proj4 = proj;
export const L = leaflet;
export const Lm = leafletMarkercluster;
# %%--- [javascript]
# properties:
#   top_hidden: true
#   bottom_hidden: true
#   run_on_load: true
# ---%%
async function fetchJson(url) {
  return fetch(url).then(response => response.json())
}

// LINREF coordinates in "ETRS89 / UTM zone 32N" (https://epsg.io/25832-1149)
var data = await fetchJson("https://raw.githubusercontent.com/akriese/harry-plotter/main/sprint_02/data/data_2021.json")

// district features https://tsb-opendata.s3.eu-central-1.amazonaws.com/lor_bezirksregionen_2021/lor_bezirksregionen_2021.geojson
// coordinates in "WGS 84 / UTM zone 33N" (https://epsg.io/32633)
// says https://www.stadtentwicklung.berlin.de/planen/basisdaten_stadtentwicklung/lor/de/download.shtml
var berlin_lor_topo = await fetchJson("https://raw.githubusercontent.com/akriese/harry-plotter/main/sprint_02/data/lor_bezirksregionen_2021.topojson")
berlin_lor_topo

# %%--- [javascript]
# properties:
#   top_hidden: true
#   bottom_hidden: true
#   run_on_load: true
# ---%%
/// We define the two different coordinate systems for proj4
proj4.defs([["EPSG:32632","+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs +type=crs"],
           ["EPSG:32633", "+proj=utm +zone=33 +datum=WGS84 +units=m +no_defs +type=crs"],
           ["WGS84","+proj=longlat +datum=WGS84 +no_defs +type=crs"]]);
function from32to33(coords) {
  return proj4("EPSG:32632", "EPSG:32633", coords)
}

var monthNames = ["Januar", "Februar", "März", "April", "Mai", "Juni", "Juli",
                    "August", "September", "Oktober", "November", "Dezember"]
var dayNames = ["Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag", "Sonntag"]
var accidentTypes = ["Fahrunfall", "Abbiegeunfall", "Einbiegen / Kreuzen-Unfall",
                      "Überschreiten-Unfall", "Unfall durch ruhenden Verkehr",
                      "Unfall im Längsverkehr", "Sonstiger Unfall"]
var gravenessMeanings = ["Tödlich", "Schwer", "Leicht"]
var involved = ["IstRad", "IstPKW", "IstFuss", "IstKrad", "IstGkfz", "IstSonstige"]
var involvedNames = {
  IstRad: "Fahrrad",
  IstPKW: "PKW",
  IstFuss: "Fußgänger",
  IstKrad: "Motorrad",
  IstGkfz: "LKW",
  IstSonstige: "Sonstige"
}

// Some added properties for each data point
data.forEach(d => {
  // Assign each data point a new parameter 'coords' holding x AND y value
  // these coordinates now match the coordinates that are used by the topojson file :)
  d.coords = from32to33([d.LINREFX, d.LINREFY]);

  // we have to cut off the last two digits of each number, as we want the "Bezirksregionen"
  // from https://www.statistik-berlin-brandenburg.de/raumbezuege#:~:text=Neue%20LOR%2DSystematik%20seit%202021
  d.lor = Math.floor(d.LOR_ab_2021 / 100);

  // Precompute list of involved per accident
  var arr = []
  for (const [key, value] of Object.entries(d)) {
    if (key.startsWith("Ist") && value === true) {
      arr.push(key.replace("Ist", ""))
    }
  }
  d.Beteiligte = arr

  // shift the days to start at monday=0, sunday=6
  // sunday is UWOCHENTAG 1
  d.day = d.UWOCHENTAG == 1 ? 6 : (d.UWOCHENTAG - 2)
})
# %%--- [javascript]
# properties:
#   top_hidden: true
#   run_on_load: true
# ---%%
/// Collection of functions that grab certain parts of the given data

// general function to count occurences of a category in one data property
// property: name of the property to count in
// categories: list of categories whose counts in property get returned
function countCategoryOccurences(data, property, categories) {
  var counter = {}
  for (c of categories) {
    counter[c] = 0
  }

  const propArr = data.map(accident => accident[property])
  for (p of propArr) {
    counter[p]++
  }

  return counter
}

// count graveness
function countGraveness(data) {
  return countCategoryOccurences(data, "UKATEGORIE", [1, 2, 3])
}

// count accident types
function countAccidentTypes(data) {
  return countCategoryOccurences(data, "UTYP1", [1, 2, 3, 4, 5, 6, 7])
}

// count the occurences of LOR in the given data, return the lor ids and their counts as an Object
function countPerLOR(data) {
  var counts = {}
  data.forEach(d => {
    const lor = d.lor
    if (lor in counts) {
      counts[lor] += 1
    } else {
      counts[lor] = 1
    }
  })

  return counts
}

// extract accident time data
// mode: one of {"single", "array", "day_arrays"} defines how the data is returned
function getDaysAndHours(data, mode="single") {
  var filtered = data.map(accident => ({ day: accident.day, hour: accident.STUNDE }));
  if (mode === "single") return filtered;
  if (mode === "array" ) {
    return {
      day: filtered.map(acc => acc.day),
      hour: filtered.map(acc => acc.hour),
    }
  }

  // else: day_arrays
  var result = Array.from(Array(7), () => [])

  for (p of filtered) {
    result[p.day].push(p.hour)
  }

  return result
}

// get numbers of how many accidents had e.g. cars involved
function getInvolvedNumbers(data) {
  var results = {}
  for (x of involved) {
    results[x] = 0
  }

  for (accident of data) {
    for (x of involved) {
      results[x] += accident[x] ? 1 : 0
    }
  }

  return results
}
# %%--- [javascript]
# properties:
#   top_hidden: true
#   bottom_hidden: true
#   run_on_load: true
# ---%%
/// Apply a filter on the overall data and return the chosen set
function filterData(data, {
  lor = undefined, // int describing the focused lor; undefined means the whole city is focused
  days = [], // list of ints, representing week days of chosen accidents; empty list means no filter
  graveness = undefined, // int describing the chosen accidents with certain graveness (1,2,3); undefined means no filter
  involved = [] // list of strings, which kind parties are involved in an accident; empty means no filter
}) {
  var filteredData = data
  if (lor !== undefined) {
    filteredData = filteredData.filter(acc => acc.lor === lor)
  }

  if (days.length != 0) {
    filteredData = filteredData.filter(acc => days.indexOf(acc.UWOCHENTAG) != -1)
  }

  if (graveness !== undefined) {
    filteredData = filteredData.filter(acc => acc.UKATEGORIE == graveness)
  }

  if (involved.length != 0) {
    filteredData = filteredData.filter(acc => {
      var skip = false
      for (inv of involved) {
        if (!acc[inv]) {
          return false
        }
      }

      return true
    });
  }

  return filteredData
}
# %%--- [javascript]
# properties:
#   top_hidden: true
#   bottom_hidden: true
#   run_on_load: true
# ---%%
// trying out the filter function
function measureFiltering(filter) {
  console.time()
  var result = filterData(data, filter)
  console.timeEnd()
  console.log(result.length)
  return result
}

measureFiltering({ graveness: 1 })
measureFiltering({ graveness: 2, involved: ["IstRad", "IstKrad"] })
measureFiltering({ graveness: 2, involved: ["IstRad"], days: [1,2,5,6] })
measureFiltering({ graveness: 2, days: [1,2,5,6] })
getInvolvedNumbers(measureFiltering({ graveness: 1, involved: ["IstRad"], days: [1,2,5,6] }))
getDaysAndHours(data, mode="day_arrays")

// trying out filters to precompute data for bar chart
getInvolvedNumbers(measureFiltering({involved: ["IstRad"]}))
countGraveness(data)
# %%--- [javascript]
# properties:
#   top_hidden: true
#   bottom_hidden: true
#   run_on_load: true
# ---%%
// Berlin topographies
var LorAreas = topojson.feature(berlin_lor_topo, berlin_lor_topo.objects.states)

// creating an LOR topo object with WGS84 as coordinate system
var LorWGS = { type: "FeatureCollection"}
LorWGS.features = LorAreas.features.map(feature => ({
  type: "Feature",
  properties: feature.properties,
  geometry: {
    type: "Polygon",
    coordinates: [feature.geometry.coordinates[0].map(coords => {
      const [x, y] = proj4("EPSG:32633", "WGS84", coords)
      return [y, x];
    })]
  }
}))

var lorNames = {}
LorWGS.features.forEach(f => {
  lorNames[parseInt(f.properties.BZR_ID)] = f.properties.BZR_NAME
})

// TODO: probably not needed anymore since we are now using leaflets polygon function
// statemesh should work as it looks like in the bubble map example
//statemesh = topojson.mesh(berlin_lor_topo, berlin_lor_topo.objects.states, (a, b) => a !== b)

var projection = d3.geoIdentity()
  .reflectY(true)
  .fitSize([1500, 1000], topojson.feature(berlin_lor_topo, berlin_lor_topo.objects.states))
# %%--- [javascript]
# properties:
#   run_on_load: true
#   bottom_hidden: true
#   top_hidden: true
# ---%%
function reveal() {
  var reveals = document.querySelectorAll(".reveal");
  for (var i = 0; i < reveals.length; i++) {
    var windowHeight = window.innerHeight;
    var elementTop = reveals[i].getBoundingClientRect().top;
    var elementVisible = 150;
    if (elementTop < windowHeight - elementVisible) {
      reveals[i].classList.add("active");
    } else {
      reveals[i].classList.remove("active");
    }
  }
}
window.addEventListener("scroll", reveal);
reveal();
# %%--- [css]
# properties:
#   top_hidden: true
#   run_on_load: true
# ---%%
*{
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  font-family: "Asap", sans-serif;
}

section{
  min-height: 100vh;
  display: flex;
  justify-content: center;
  align-items: center;
}
section:nth-child(1){
  color: #ff0808;
  }

section .container{
  margin: 100px;
  max-width: 100%;
}
section h1{
  font-size: 3rem;
  margin: 20px;
}
section h2{
  font-size: 40px;
  text-align: center;
  text-transform: uppercase;
}
section .text-container{
   display: flex;
}
section .text-container .text-box{
  margin: 20px;
  padding: 20px;
}

@media (max-width: 900px){
  section h1{
    font-size: 2rem;
    text-align: center;
  }
  section .text-container{
    flex-direction: column;
  }
}

.reveal{
  position: relative;
  transform: translateY(150px);
  opacity: 0;
  transition: 1s all ease;
}

.reveal.active{
  transform: translateY(0);
  opacity: 1;
}

.left-container {
  float: left;
  width: 50%;
}

.left-content {
  width: 100%;
}
.right-container {
  display: flex;
  align-items: center;
  justify-content: space-around;
  height: 40vw;
  width: 50%;
  float: left;
}

.right-content {
  max-width: 70%;}
# %%--- [html]
# properties:
#   run_on_load: true
# ---%%

<body>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=" crossorigin="" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
<section>
    <div id= "titel" class="container reveal">
  		<h1 style="text-align:center">Übersicht der Verkehrsunfälle in Berlin im Jahr 2021</h1>
    </div>
  </section>
  
  <section>
    <div id= "introduction" class="container ">
      <h1 class= "reveal" style="text-align:center">Im Jahr 2021 wurden in Berlin ca. 11300 Menschen bei Verkehrsunfällen verletzt oder getötet.</h1>
    </div>
  </section>
  
 <section>
    <div id= "introduction2" class="container ">
       <h1 class= "reveal" style="text-align:center">Dieses interaktive Tool soll Ihnen als Stadt- oder Verkehrsplaner eine Hilfe sein, Verkehrsunfälle aus 
         unterschiedlichen Blickwinkeln zu betrachten, mögliche Ursachen zu erforschen und besonders gefährdete Gebiete zu erkennen.
         <br><br>Lassen Sie uns zunächst den zetlichen Aspekt betrachten.</h1>
    </div>
  </section>
  
  <section>
    <div id="askforViolin" class="container">
       	<h1 class= "reveal" style="text-align:center">Zu welchen Zeiten finden die meisten Verkehrsunfälle statt?</h1>
    </div>
  </section>
  
  <section>
    <div id="violin" class="left-container">
      <div id="Mapgrafik" class="left-content">
    	<div class= "reveal"  id=test_violin></div>
    </div>
      </div>

            <div class="right-container">
      <div class="right-content reveal">
        Hier sehen Sie die Verteilung der Unfälle über Tage und Stunden. Besonders auffällig ist, dass am Wochenende (insbesondere am Sonntag) die 
        wenigsten Unfälle stattfinden. An Werktagen lassen sich zwischen 7-9 Uhr und zwischen 15-18 Uhr zwei Peaks erkennen, die in etwa den Zeiten 
        entsprechen, zu denen viele Menschen zur Arbeit/von der Arbeit nach Hause fahren. Allerdingsfinden auch dazwischen recht viele Unfälle statt.
        Zu Zeiten, zu denen üblicherweise geschlafen wird und somit auch auf den Straßen wenig los ist, finden - wie zu erwarten - kaum Unfälle statt.
        </div>
    </div>
  </section>

    <section>
      <div  class="left-content">
    	<h1 class= "reveal"  style="text-align:center">Nun folgt eine kleine Einführung in die verschiedenen interaktiven Elemente unseres Tools,
          um Ihnen den Umgang damit zu erleichtern und Sie auf bestimmte Funktionsweisen aufmerksam zu machen.</h1>
    </div> 
      </section>
  
  <section>
    <div id="map_e" class="left-container">
    	 <div class="left-content">
      		<h1 class= "reveal">Map</h1>
        </div>
    </div>
    <div class="right-container">
      <div class="right-content reveal">
        Das Hauptelement der Darstellung ist eine Karte. Sie können darin wie gewohnt rein- und rauszoomen indem Sie scrollen, und die Karte mit der linken Maustaste bewegen. Die Farbe der eingezeichneten 
        lebensorientierten Räume (LOR) zeigt die unnormierte Anzahl der Verkehrsunfälle in dem jeweiligen LOR an. Die farbigen Kreise auf der Karte fassen einzelne Unfallpunkte zusammen, die bei dem 
        momentanen Zoomlevel nah beieinander liegen. Durch reinzoomen werden diese in der Regel in kleinere Agglomerationen aufgeteilt, bis ab einem gewissen Zoomfaktor nur die einzelnen Unfallstellen 
        sichtbar sind. Um die einzelnen Unfallstellen sichtbar zu machen, kann auch auf einen der farbigen Kreise geklickt werden. Wenn Sie mit der Maus über einem der LORs oder einer einzelnen Unfallstelle
        hovern, erscheint ein Tooltip mit näheren Informationen.
	  </div>
    </div>
  </section>

      <section>
    <div id="GRAVENESS_e" class="left-container">
      <div id=gravenessDiagrammTutorial class= "reveal" ></div>
    </div>
          <div class="right-container">
      <div class="right-content reveal">
        In diesem Graphen wird der maximale Schweregrad der Unfälle dargestellt. Wenn Sie auf einen der LOR in der Karte klicken wird diese Darstellung aktualisiert und es werden nur Informationen zu
        dem jeweiligen LOR gezeigt. Ebenso können Sie auf einen der Balken oder eine der Beschriftungen der y-Axe klicken, um z.B. nur Unfälle mit Schwerverletzten anzuzeigen. Dies gilt auch für die nächste Darstellung.
        </div>
    </div>
  </section>

      <section>
    <div id="beteiligte_e" class="left-container">
      <div id=involvedDiagrammTutorial  class= "reveal" ></div>
    </div>
          <div class="right-container">
      <div class="right-content reveal">
        Ähnlich wie bei dem darüberliegenden Graphen, können Sie auch hier einen der Balken anklicken, um sich z.B. nur Unfälle mit PKW-Beteiligung anzeigen zu lassen. Sowohl die Karte,
        als auch das Balkendiagramm mit Schweregraden werden dadurch aktualisiert. Falls Sie nicht mehr sicher sein sollten, was Sie im Moment ausgewählt haben, wird Ihnen diese Information
        in der rechten oberen Ecke der Gesamtdarstellung angezeigt.
        </div>
    </div>
  </section>  

  <section>
      <div  class="left-content">
    	<h1 class= "reveal"  style="text-align:center">Welche Orte sind besonders gefährlich - und für wen?
        <br><br>Wo bedarf es zusätzlicher Schutzmaßnahmen?</h1>
    </div> 
      </section>

  <section>
    <div class="container reveal">
  <svg id=legend></svg>
  <div id=main>
      <div id=map><h1>MAP</h1></div>
      <div id=right>
        <div id=infoText><h1>INFO</h1></div>
        <div id=gravenessDiagramm><h1>GRAVENESS</h1></div>
        <div id=involvedDiagramm><h1>Beteiligte</h1></div>
      </div>
  </div>
      </div>
  </section>
    <h6>Quelle: <a href="https://daten.berlin.de/datensaetze/stra%C3%9Fenverkehrsunf%C3%A4lle-nach-unfallort-berlin-2021">daten.berlin.de</a></h6>
</body>
# %% [markdown]
## Map implementation
# %%--- [javascript]
# properties:
#   top_hidden: true
#   bottom_hidden: true
#   run_on_load: true
# ---%%
function makeTooltipContent(accident) {
  const info = accident
  const persons = "<b>Beteiligte:</b> " + info.Beteiligte.join(", ")
  const dateTime = "<b>Monat/Tag/Uhrzeit:</b> " + monthNames[info.UMONAT - 1] +
                   "; " + dayNames[info.day] +
                   "; " + info.USTUNDE + " Uhr";
  const graveness = "<b>Schweregrad:</b> " + gravenessMeanings[info.UKATEGORIE - 1]

  return "<b>" + accidentTypes[info.UTYP1 - 1] + "</b><br>"
               + dateTime + "<br>"
               + persons + "<br>"
               + graveness + "<br>";
}
# %%--- [javascript]
# properties:
#   top_hidden: true
#   bottom_hidden: true
#   run_on_load: true
# ---%%
// Inspired by https://observablehq.com/@tmcw/d3-scalesequential-continuous-color-legend-example
function colorLegend(colorScale, {
  map = undefined,
  selection = undefined,
  width = 300,
  height = 50,
  margin = ({top: 40, right: 40, bottom: 30, left: 40}),
  barHeight = 20
}) {
  axisScale = d3.scaleLinear()
    .domain(colorScale.domain())
    .range([margin.left, width - margin.right])

  axisBottom = g => g
    .attr("class", `x-axis`)
    .attr("transform", `translate(0,${height - margin.bottom})`)
    .call(d3.axisBottom(axisScale)
      .ticks(width / 50)
      .tickSize(-barHeight))
  //DOM.svg(width, height)

  const svg = selection === undefined ?
    document.createElementNS('http://www.w3.org/2000/svg', 'svg') :
    selection.append("svg").attr('transform', `translate(${300}, 20)`)

  const defs = svg.append("defs");
  const linearGradient = defs.append("linearGradient")
    .attr("id", "linear-gradient");

  linearGradient.selectAll("stop")
    .data(colorScale.ticks().map((t, i, n) => ({ offset: `${100*i/n.length}%`, color: colorScale(t) })))
    .enter().append("stop")
    .attr("offset", d => d.offset)
    .attr("stop-color", d => d.color);

  svg.append('g')
    .attr("transform", `translate(0,${height - margin.bottom - barHeight})`)
    .append("rect")
    .attr('transform', `translate(${margin.left}, 0)`)
    .attr("width", width - margin.right - margin.left)
    .attr("height", barHeight)
    .style("fill", "url(#linear-gradient)");

  svg.append('g')
    .call(axisBottom);

  if (map) map.getContainer().appendChild(selection.node())

  return svg.node();
}
# %%--- [javascript]
# properties:
#   top_hidden: true
#   bottom_hidden: true
#   run_on_load: true
# ---%%
function StateColors(counts) {
  counts.dummy = 0
  const c = Object.entries(counts).map(([_, count]) => count)
  const [min, max] = [Math.min(...c), Math.max(...c)]
  const colorScale = d3.scaleSequential(d3.interpolateReds).domain([min, max])

  const scaler = function(stateId) {
    return stateId in counts ? colorScale(counts[stateId]) : colorScale(counts.dummy)
  }

  return [scaler, colorScale]
}

const markerMultiplier = 1.1 // change this to increase or decrease the marker size
const iconSize = [38*markerMultiplier, 38*markerMultiplier]
var blackMarkerIcon = L.icon({
    iconUrl: 'https://raw.githubusercontent.com/akriese/harry-plotter/anton/sprint_02/data/icons8-map-pin-100.png',

    iconSize:     iconSize, // size of the icon
    iconAnchor:   [iconSize[0] / 2, iconSize[1]], // point of the icon which will correspond to marker's location
    popupAnchor:  [-15, -38] // point from which the popup should open relative to the iconAnchor
});

function LeafletAccidentMap(data, {
  topo,
  topoCoordSystem = "EPSG:32633",
  divName = "mother",
  legendSvgName = "legendSvg",
  minZoom = 11,
  maxZoom = 19,
  states, // FeatureCollection of topojson data
  stateTitle, // function to get the title from a state feature
  stateCount, // function to count the occurences per state in the data
  stateId, // function to get the ID of a given state
  tooltipContent, // function to create the content of a tooltip for the given datapoint
  dotCoords, // function to get the WGS84 (x, y) coordinates from a data point
  stateStrokeInactive = 0.0, // state border stroke thickness, while neither focused nor hovered over
  stateStrokeClicked = 3.0, // state border stroke thickness, while focused
  stateStrokeHover = 1.0, // state border stroke thickness, while hovered over
}) {
  // get topo bounds and convert them to WGS84, but with LatLong format (x and y switched)
  var bounds = topojson.bbox(topo)
  var boundsArr = [bounds.slice(0, 2), bounds.slice(2, 4)]
  var projBounds = [proj4(topoCoordSystem, "WGS84", boundsArr[0]).reverse(),
                    proj4(topoCoordSystem, "WGS84", boundsArr[1]).reverse()]

  const mod = { initBounds: projBounds, markersCluster: undefined }

  // draw map
  mod.map = L.map(divName, { doubleClickZoom: false }).fitBounds(projBounds);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    minZoom: minZoom,
    maxZoom: maxZoom,
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
  }).addTo(mod.map);

  L.control.scale().addTo(mod.map);

  // A dummy state we need for when no state is focussed, needs to implement unfocus to prevent error
  mod.dummyState = { unfocus: function() {} }
  mod.currentlyFocusedState = mod.dummyState

  // zoom out to see whole city
  mod.resetView = function(e) {
    this.map.fitBounds(this.initBounds)
    this.currentlyFocusedState.unfocus()
    this.currentlyFocusedState = this.dummyState
    if (mod.manager !== undefined) mod.manager.trigger({ lor: undefined })
    L.DomEvent.stopPropagation(e); // dont propagate click to map, otherwise mod.resetView() is called
  }

  mod.map.on("click", event => mod.resetView(event))

  // create the LOR polygons and give them click behavior
  mod.states = states.features.map(f => {
    const polygon = L.polygon(f.geometry.coordinates[0],
            { stroke: true, color: "black", weight: stateStrokeInactive, fillOpacity: 0.8 })

    // change stroke when focussing state
    polygon.focus = function(e) {
      mod.map.fitBounds(this.getBounds())
      mod.currentlyFocusedState.unfocus()
      mod.currentlyFocusedState = this
      this.setStyle({ weight: stateStrokeClicked })
      if (mod.manager !== undefined) mod.manager.trigger({ lor: stateId(this) })
      L.DomEvent.stopPropagation(e); // dont propagate click to map, otherwise mod.resetView() is called
    }

    // reset border stroke when unfocussing a state
    polygon.unfocus = function() {
      this.setStyle({ weight: stateStrokeInactive })
    }

    polygon.isFocused = function() {
      return mod.currentlyFocusedState === this
    }

    // ATTENTION: dblclick might also fire click twice, so dont do anything with different side effects in click!
    polygon
      .on("click", event => polygon.isFocused() ? mod.resetView(event) : polygon.focus(event))
      //.on("dblclick", () => mod.resetView())
      // these functions implement the highlighting of states that are currently hovered over
      .on("mouseover", () => polygon.isFocused() ? {} : polygon.setStyle({ weight: stateStrokeHover }))
      .on("mouseout", () => polygon.isFocused() ? {} : polygon.setStyle({ weight: stateStrokeInactive }))
      .addTo(mod.map)

    polygon.properties = f.properties
    return polygon
  });

  mod.update = function(data) {
    // update polygon colors
    const counts = stateCount(data)
    const [scaler, colorScale] = StateColors(counts)
    mod.colorScale = colorScale
    this.states.forEach(p => {
      const id = stateId(p)
      p.setStyle({fillColor: scaler(id)})
      p.bindTooltip(`${stateTitle(p)} (${counts[id]} Unfälle)`) // TODO: maybe handle case count == 1?
    })

    // update color legend (by replacing it completely)
    const selection = d3.select(`#${legendSvgName}`)
    // remove old legend if it is available
    const oldLegend = selection.node().lastElementChild
    if (oldLegend !== null) oldLegend.remove()
    // draw new legend
    colorLegend(mod.colorScale, { selection: selection, map: mod.map })

    // remove marker cluster layer if existent
    if (this.markersCluster !== undefined) {
      this.map.removeLayer(this.markersCluster)
      delete this.markersCluster
    }

    // set accidentMarkers
    this.markersCluster = L.markerClusterGroup({ showCoverageOnHover: false });

    data.forEach(d => {
      const dot = L
        .marker(dotCoords(d).reverse(), {icon: blackMarkerIcon})
        .bindTooltip(tooltipContent(d))
      this.markersCluster.addLayer(dot)
    })

    this.map.addLayer(this.markersCluster);
    return this
  }

  // change polygon color scale on zoom
  mod.map.on('zoomend', () => {
    var zoom = mod.map.getZoom();
    const minOpacity = 0.01 // zoom == maxZoom => opacity = minOpacity
    const maxOpacity = 0.8 // zoom == minZoom => opacity = maxOpacity
    const multiplier = (maxZoom - zoom) / (maxZoom - minZoom) // number between 0 and 1; zoom normalized
    // do a cubic descent of opacity to see the underlying map earlier
    const newOpacity = (maxOpacity - minOpacity) * Math.pow(multiplier, 3) + minOpacity
    mod.states.forEach((s) => s.setStyle({ fillOpacity: newOpacity }))
  });

  mod.update(data)

  return mod;
}
# %%--- [javascript]
# properties:
#   top_hidden: true
#   bottom_hidden: true
#   run_on_load: true
# ---%%
var mapModule = LeafletAccidentMap(data, {
  topo: berlin_lor_topo,
  states: LorWGS,
  divName: "map",
  legendSvgName: "legend",
  dotCoords: d => ([d.XGCSWGS84, d.YGCSWGS84]),
  tooltipContent: acc => makeTooltipContent(acc),
  stateTitle: f => f.properties.BZR_NAME,
  stateCount: countPerLOR,
  stateId: p => parseInt(p.properties.BZR_ID),
})
# %%--- [javascript]
# properties:
#   top_hidden: true
#   bottom_hidden: true
#   run_on_load: true
# ---%%
function removeAllChildren(name) {
  const div = document.getElementById(name);
  let child = div.lastElementChild;
  while (child !== null) {
    div.removeChild(child);
    child = div.lastElementChild;
  }
}
# %% [markdown]
## Involved chart
# %%--- [javascript]
# properties:
#   top_hidden: true
#   bottom_hidden: true
#   run_on_load: true
# ---%%
// helper functions to model data as needed
function get_data_object_bar_chart(data, numberFct) {
  let categoryCounts = numberFct(data);
  return Object.entries(categoryCounts).map(([key, val]) => ({category: key, count: val}));
}

// returns category without "Ist"
function toNiceNames(cat){
  cat.category = involvedNames[cat.category];
}

// returns category with its meaning
function get_meaning(data_dict){
  data_dict.category = gravenessMeanings[data_dict.category - 1];
}
# %%--- [javascript]
# properties:
#   top_hidden: true
#   bottom_hidden: true
#   run_on_load: true
# ---%%
// Copyright 2021 Observable, Inc.
// Released under the ISC license.
// https://observablehq.com/@d3/bar-chart
function BarChart(data, {
  x = (d, i) => i, // given d in data, returns the (ordinal) x-value
  y = d => d, // given d in data, returns the (quantitative) y-value
  title, // given d in data, returns the title text
  marginTop = 60, // the top margin, in pixels
  marginRight = 0, // the right margin, in pixels
  marginBottom = 30, // the bottom margin, in pixels
  marginLeft = 40, // the left margin, in pixels
  width = 640, // the outer width of the chart, in pixels
  height = 400, // the outer height of the chart, in pixels
  xRange = [marginLeft, width - marginRight], // [left, right]
  yType = d3.scaleLinear, // y-scale type
  yDomain, // [ymin, ymax]
  yRange = [height - marginBottom, marginTop], // [bottom, top]
  xPadding = 0.1, // amount of x-range to reserve to separate bars
  yFormat, // a format specifier string for the y-axis
  yLabel, // a label for the y-axis
  titleColor = "black", // title fill color when atop bar
  titleAltColor = "currentColor", // title fill color when atop background
  divName,
} = {}) {
  removeAllChildren(divName);
  const mod = {}

  let barData = get_data_object_bar_chart(data, getInvolvedNumbers);
  barData.map(toNiceNames)
  // Compute values.
  let X = d3.map(barData, x);
  let Y = d3.map(barData, y);
  let xDomain = d3.groupSort(barData, ([d]) => -d.count, d => d.category); // sort by descending frequency;

  // Compute default domains, and unique the x-domain.
  if (xDomain === undefined) xDomain = X;
  if (yDomain === undefined) yDomain = [0, d3.max(Y)];
  xDomain = new d3.InternSet(xDomain);

  // Omit any data not present in the x-domain.
  let I = d3.range(X.length).filter(i => xDomain.has(X[i]));

  // Construct scales, axes, and formats.
  let xScale = d3.scaleBand(xDomain, xRange).padding(xPadding);
  let yScale = d3.scaleLinear(yDomain, yRange);//d3.scaleBand(yDomain, yRange);
  let xAxis = d3.axisBottom(xScale).tickSizeOuter(0);
  let yAxis = d3.axisLeft(yScale).ticks(height / 40, yFormat);

  // setted color can be changed by using another schemeCategory
  let color = d3.scaleOrdinal(barData.map(d => d.category), d3.schemeCategory10).unknown("red");
  let col = d3.map(barData, (d) => color(d.category));

  // Compute titles.
  if (title === undefined) {
    let formatValue = yScale.tickFormat(100, yFormat);
    title = i => `${formatValue(Y[i])}`;
  } else {
    let O = d3.map(barData, d => d);
    let T = title;
    title = i => T(O[i], i, barData);
  }

  let svg = d3.select(`#${divName}`).append("svg")
    .attr("width", width)
    .attr("height", height)
    .attr("viewBox", [0, 0, width, height])
    .attr("style", "max-width: 100%; height: auto; height: intrinsic;");

  //title
  svg.append("text")
    .attr("x", (width / 2 + 30))
    .attr("y", 30 )
    .attr("text-anchor", "middle")
    .attr("font-family", "sans-serif")
    .style("font-size", "16px")
    .text("Anzahl der Unfälle je Gruppe von Beteiligten");

  let yAxe = svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(yAxis)
    .call(g => g.select(".domain").remove())
    .call(g => g.selectAll(".tick line").clone()
      .attr("x2", width - marginLeft - marginRight)
      .attr("stroke-opacity", 0.1))
    .call(g => g.append("text")
      .attr("x", -marginLeft)
      .attr("y", 50)
      .attr("fill", "currentColor")
      .attr("text-anchor", "start")
      .text(yLabel));

  let bar = svg.append("g")
    .selectAll("rect")
    .data(I)
    .join("rect")
      .attr("x", i => xScale(X[i]))
      .attr("y", i => yScale(Y[i]))
      .attr("height", i => yScale(0) - yScale(Y[i]))
      .attr("width", xScale.bandwidth())
      .attr("cursor", "pointer")
      .attr("fill", i => col[i]);

  if (title) bar.append("title").text(title);

  let bartext = svg.append("g")
    .attr("fill", "currentColor")
    .attr("text-anchor", "end")
    .attr("font-family", "sans-serif")
    .attr("font-size", 10)
    .selectAll("text")
    .data(I)
    .join("text")
      .attr("y", i => yScale(Y[i]) - 7)
      .attr("x", i => xScale(X[i]) + xScale.bandwidth() / 3)
      .attr("dy", "0.35em")
      .attr("dx", -4)
      .text(title)
      .call(text=> text.filter(i => yScale(Y[i]) - yScale(0) < 20) // short bars
        .attr("dy", +4)
        .attr("fill", titleAltColor)
        .attr("text-anchor", "start"));

  svg.append("g")
    .attr("transform", `translate(0,${height - marginBottom})`)
    .call(xAxis);

  mod.focusedBar = undefined
  mod.clickBar = function(cat) {
    if (mod.focusedBar === undefined || mod.focusedBar != cat) {
      let niceName = X[cat]
      let officialName = Object.entries(involvedNames).find(([k, v]) => v === niceName)[0]
      mod.manager.trigger({ involved: [officialName] })
      bar
        .transition()
        .duration(200)
        .style("opacity", i => i === cat ? 1.0 : 0.4)
      mod.focusedBar = cat;
    } else { // focus all again
      mod.manager.trigger({ involved: [] })
      bar
        .transition()
        .duration(200)
        .style("opacity", 1.0)
      mod.focusedBar = undefined;
    }
  }

  bar.on("click", (e, cat) => mod.clickBar(cat))

  mod.update = function(data) {
    let barData = get_data_object_bar_chart(data, getInvolvedNumbers);
    barData.forEach(toNiceNames) // map -> principle of least astonishment

    // update bar heigth
    let Y = d3.map(barData, y);
    let yDomain = [0, d3.max(Y)]
    let yScale = d3.scaleLinear(yDomain, yRange);

    let yAxis = d3.axisLeft(yScale).ticks(height / 40, yFormat);
    yAxe.selectAll("*").remove()
    yAxe.attr("transform", `translate(${marginLeft},0)`)
      .call(yAxis)
        .call(g => g.select(".domain").remove())
        .call(g => g.append("text")
          .attr("x", -marginLeft)
          .attr("y", 50)
          .attr("fill", "currentColor")
          .attr("text-anchor", "start")
          .text(yLabel));

    // update bar height
    bar.transition().duration(500).attr("y", i => yScale(Y[i])).attr("height", i => yScale(0) - yScale(Y[i]))

    // update text height
    bartext.transition().duration(500).attr("y", i => yScale(Y[i]) - 7)

    let formatValue = yScale.tickFormat(100, yFormat);
    title = i => `${formatValue(Y[i])}`;

    bartext.data(I)
      .join("text")
        .attr("y", i => yScale(Y[i]) - 7)
        .attr("x", i => xScale(X[i]) + xScale.bandwidth() / 3)
        .attr("dy", "0.35em")
        .attr("dx", -4)
        .text(title)
        .call(text => text.filter(i => yScale(Y[i]) - yScale(0) < 20) // short bars
          .attr("dy", +4)
          .attr("fill", titleAltColor)
          .attr("text-anchor", "start"));

    return this
  }

  return mod;
}
# %%--- [javascript]
# properties:
#   run_on_load: true
#   top_hidden: true
#   bottom_hidden: true
# ---%%

var moduleInvolvedChart = BarChart(data, {
  x: d => d.category, // x=> xScale(X[i])). axis -> category
  y: d => d.count, // counts
  yLabel: "↑ Anzahl",
  width: 500,
  height: 400, // think about deceptive design
  divName: "involvedDiagramm",
  //title: "Anzahl der Unfälle per Beteiligte",
})
# %%--- [javascript]
# properties:
#   bottom_hidden: true
#   top_hidden: true
#   run_on_load: true
# ---%%
var moduleInvolvedChartTutorial = BarChart(data, {
x: d => d.category, // x=> xScale(X\[i\])). axis -> category
y: d => d.count, // counts
yLabel: "↑ Anzahl",
width: 500,
height: 400, // think about deceptive design
divName: "involvedDiagrammTutorial",
//title: "Anzahl der Unfälle per Beteiligte",
})
# %%--- [javascript]
# properties:
#   bottom_hidden: true
#   top_hidden: true
#   run_on_load: true
# ---%%
moduleInvolvedChartTutorial.clickBar = () => {}
# %% [markdown]
## Graveness chart
# %%--- [javascript]
# properties:
#   top_hidden: true
#   bottom_hidden: true
#   run_on_load: true
# ---%%
// Copyright 2021 Observable, Inc.
// Released under the ISC license.
// https://observablehq.com/@d3/horizontal-bar-chart
function BarChartH(data, {
  x = d => d, // given d in data, returns the (quantitative) x-value
  y = (d, i) => i, // given d in data, returns the (ordinal) y-value
  title, // given d in data, returns the title text
  marginTop = 80, // the top margin, in pixels
  marginRight = 30, // the right margin, in pixels
  marginBottom = 10, // the bottom margin, in pixels
  marginLeft = 50, // the left margin, in pixels
  width = 640, // the outer width of the chart, in pixels
  height, // outer height, in pixels
  xDomain, // [xmin, xmax]
  xRange = [marginLeft, width - marginRight], // [left, right]
  xFormat, // a format specifier string for the x-axis
  xLabel, // a label for the x-axis
  yPadding = 0.1, // amount of y-range to reserve to separate bars
  yRange, // [top, bottom]
  color = "currentColor", // bar fill color
  titleColor = "black", // title fill color when atop bar
  titleAltColor = "currentColor", // title fill color when atop background
  divName,
} = {}) {
  removeAllChildren(divName)
  mod = {};

  // get correct data format
  data = get_data_object_bar_chart(data, countGraveness);
  data.map(get_meaning)

  var yDomain = d3.groupSort(data, ([d]) => d.count, d => d.category); // sort by descending frequency

  // Compute values.
  const X = d3.map(data, x);
  const Y = d3.map(data, y);

  // Compute default domains, and unique the y-domain.
  if (xDomain === undefined) xDomain = [0, d3.max(X)];
  if (yDomain === undefined) yDomain = Y;
  yDomain = new d3.InternSet(yDomain);

  // Omit any data not present in the y-domain.
  const I = d3.range(X.length).filter(i => yDomain.has(Y[i]));

  // Compute the default height.
  if (height === undefined) height = Math.ceil((yDomain.size + yPadding) * 25) + marginTop + marginBottom;
  if (yRange === undefined) yRange = [marginTop, height - marginBottom];

  // Construct scales and axes.
  const xScale = d3.scaleLinear(xDomain, xRange);
  const yScale = d3.scaleBand(yDomain, yRange).padding(yPadding);
  const xAxis = d3.axisTop(xScale).ticks(width / 80, xFormat);
  const yAxis = d3.axisLeft(yScale).tickSizeOuter(0);
  var color = d3.scaleOrdinal(data.map(d => d.category), ["red", "orange", "green"]).unknown("grey");
  const col = d3.map(data, (d) => color(d.category));

  // Compute titles.
  if (title === undefined) {
    const formatValue = xScale.tickFormat(100, xFormat);
    title = i => `${formatValue(X[i])}`;
  } else {
    const O = d3.map(data, d => d);
    const T = title;
    title = i => T(O[i], i, data);
  }

  const svg = d3.select(`#${divName}`).append("svg")
    .attr("width", width)
    .attr("height", height)
    .attr("viewBox", [0, 0, width, height])
    .attr("style", "max-width: 100%; height: auto; height: intrinsic;");

  //title
  svg.append("text")
    .attr("x", (width / 2 + 30))
    .attr("y", 30 )
    .attr("text-anchor", "middle")
    .attr("font-family", "sans-serif")
    .style("font-size", "16px")
    .text("Anzahl der Unfälle je Schweregrad");

  const xAxe = svg.append("g")
    .attr("transform", `translate(0,${marginTop})`)
    .call(xAxis)
    .call(g => g.select(".domain").remove())
    .call(g => g.selectAll(".tick line").clone()
      .attr("y2", height - marginTop - marginBottom)
      .attr("stroke-opacity", 0.1))
    .call(g => g.append("text")
      .attr("x", width - marginRight)
      .attr("y", -22)
      .attr("fill", "currentColor")
      .attr("text-anchor", "end")
      .text(xLabel));

  const bar = svg.append("g")
    .selectAll("rect")
    .data(I)
    .join("rect")
      .attr("x", xScale(0))
      .attr("y", i => yScale(Y[i]))
      .attr("width", i => xScale(X[i]) - xScale(0))
      .attr("height", yScale.bandwidth())
      .attr("fill", i => col[i])
      .attr("cursor", "pointer")
      .attr("category", i => i)
      .style("opacity", 1.0);

  mod.focusedBar = undefined
  mod.clickBar = function(idx) {
    let categoryNum = idx + 1
    console.log(categoryNum)
    if (mod.focusedBar === undefined || mod.focusedBar != idx) {
      mod.manager.trigger({ graveness: categoryNum })
      bar
        .transition()
        .duration(200)
        .style("opacity", i => i === idx ? 1.0 : 0.4)
      mod.focusedBar = idx;
    } else { // focus all again
      mod.manager.trigger({ graveness: undefined })
      bar
        .transition()
        .duration(200)
        .style("opacity", 1.0)
      mod.focusedBar = undefined;
    }
  }

  bar.on("click", (e, i_) => mod.clickBar(i_))

  const bar_title = svg.append("g")
    .attr("fill", titleColor)
    .attr("text-anchor", "end")
    .attr("font-family", "sans-serif")
    .attr("font-size", 10)
    .selectAll("text")
    .data(I)
    .join("text")
      .attr("x", i => xScale(X[i]))
      .attr("y", i => yScale(Y[i]) + yScale.bandwidth() / 2)
      .attr("dy", "0.35em")
      .attr("dx", +30)
      .text(title)
      .call(text => text.filter(i => xScale(X[i]) - xScale(0) < 0) // short bars
        .attr("dx", +4)
        .attr("fill", titleAltColor)
        .attr("text-anchor", "start"));

  svg.append("g")
    .attr("transform", `translate(${marginLeft},0)`)
    .call(yAxis)
    .selectAll(".tick")
      .attr("cursor", "pointer")
      .on("click", (e, cat) => mod.clickBar(gravenessMeanings.indexOf(cat)))

  mod.update = function(data) {
    data = get_data_object_bar_chart(data, countGraveness);
    data.map(get_meaning)

    // update bar heigth
    const X = d3.map(data, x);
    xDomain = [0, d3.max(X)]
    const xScale =  d3.scaleLinear(xDomain, xRange);

    const xAxis = d3.axisTop(xScale).ticks(width / 80, xFormat);

    xAxe.selectAll("*").remove()
    xAxe.call(xAxis)
      .call(g => g.select(".domain").remove())
      .call(g => g.selectAll(".tick line").clone()
        .attr("y2", height - marginTop - marginBottom)
        .attr("stroke-opacity", 0.1))
      .call(g => g.append("text")
        .attr("x", width - marginRight)
        .attr("y", -22)
        .attr("fill", "currentColor")
        .attr("text-anchor", "end")
        .text(xLabel));

    bar.transition().duration(500)
      .attr("x", xScale(0))
      .attr("width", i => xScale(X[i]) - xScale(0));

    bar_title.transition().duration(500)
      .attr("x", i => xScale(X[i]))

    const formatValue = xScale.tickFormat(100, xFormat);
    title = i => `${formatValue(X[i])}`;

    bar_title
      .data(I)
      .join("text")
        .attr("x", i => xScale(X[i]))
        .attr("y", i => yScale(Y[i]) + yScale.bandwidth() / 2)
        .attr("dy", "0.35em")
        .attr("dx", +30)
        .text(title)
        .call(text => text.filter(i => xScale(X[i]) - xScale(0) < 0) // short bars
          .attr("dx", +4)
          .attr("fill", titleAltColor)
          .attr("text-anchor", "start"));

    return this
  }

  return mod;
}
# %%--- [javascript]
# properties:
#   bottom_hidden: true
#   top_hidden: true
#   run_on_load: true
# ---%%

var moduleGravenessChart = BarChartH(data, {
  x: d => d.count, // x axis -> counts
  y: d => d.category, // y-axis -> counts
  xLabel: "Anzahl →",
  width: 500,
  height: 300, // think about deceptive design
  marginLeft: 80,
  divName: "gravenessDiagramm",
  //title: "Gesamtanzahl der Unfälle per Beteiligte",
})
# %%--- [javascript]
# properties:
#   run_on_load: true
#   bottom_hidden: true
#   top_hidden: true
# ---%%
var moduleGravenessChartTutorial = BarChartH(data, {
  x: d => d.count, // x axis -> counts
  y: d => d.category, // y-axis -> counts
  xLabel: "Anzahl →",
  width: 500,
  height: 300, // think about deceptive design
  marginLeft: 80,
  divName: "gravenessDiagrammTutorial",
  //title: "Gesamtanzahl der Unfälle per Beteiligte",
})
# %%--- [javascript]
# properties:
#   run_on_load: true
#   bottom_hidden: true
#   top_hidden: true
# ---%%
moduleGravenessChartTutorial.clickBar = () => {}
# %% [markdown]
## Violin plot for amount of crash per days and hour

* https://d3-graph-gallery.com/graph/violin_jitter.html

\

# %%--- [javascript]
# properties:
#   top_hidden: true
#   bottom_hidden: true
#   run_on_load: true
# ---%%
function hist_all_over(data, histogram) {
  sorted_data = data.slice().sort((a, b) => d3.ascending(a.day, b.day));
  data_grouped = d3.group(sorted_data, d => d.day);
  bins = Array.from(data_grouped).map(d => d[1].map(d => d.USTUNDE)).map(histogram);
  return bins
};
# %%--- [javascript]
# properties:
#   top_hidden: true
#   bottom_hidden: true
#   run_on_load: true
# ---%%
function RaincloudPlot(data) {
  // Build and Show the Y scale

  // set the dimensions and margins of the graph
  var margin = {top: 20, right: 40, bottom: 10, left: 300},
    width = 1100 - margin.left - margin.right,
    height = 750; // - margin.top - margin.bottom;

  var x = d3.scaleLinear()
    .domain([0, 24])          // Note that here the Y scale is set manually // days
    .range([0, width])

  // Build and Show the X scale. It is a band scale like for a boxplot: each group has an dedicated RANGE on the axis. This range has a length of x.bandwidth
  var y = d3.scaleBand()
    .range([0, height])
    .domain([...Array(7).keys()]) // days
    .padding(0)     // This is important: it is the space between 2 groups. 0 means no padding. 1 is the maximum.

  // Create the Y axis for names
  var yName = d3.scaleBand()
    .domain(dayNames)
    .range([0, height])
    .paddingInner(0)

  // Features of the histogram
  var histogram = d3.histogram()
    .domain(x.domain())
    .thresholds(x.ticks(24))    // Important: how many bins approx are going to be made? It is the 'resolution' of the violin plot
    .value(d => d)

  // Compute the binning for each group of the dataset
  var sumstat = hist_all_over(data, histogram);

  // What is the biggest number of value in a bin? We need it cause this value will have a width of 100% of the bandwidth.
  var maxNum = 0
  for (i in sumstat){
    let allBins = sumstat[i]
    let lengths = allBins.map(a => a.length)
    let longest = d3.max(lengths)
    if (longest > maxNum) { maxNum = longest }
  }

  // adapt data structure inner array to dict
  for (i in sumstat){
    let dict = {};
    dict[i] = sumstat[i];
    sumstat[i] = dict;
  }

  // The maximum width of a violin must be x.bandwidth = the width dedicated to a group
  var yNum = d3.scaleLinear()
    .range([0, y.bandwidth()])
    .domain([-maxNum, maxNum])

  // append the svg object to the body of the page
  const svg = d3.select("#test_violin")
    .append("svg")
      .attr("width", width)// + margin.left + margin.right)
      .attr("height", height)// + margin.top + margin.bottom)
      .attr("viewBox", [-120, 0, width + 200, height + 30])
      .attr("style", "max-width: 100%; height: auto; height: intrinsic;");

  svg.append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

  // add x-axis
  svg.append("g")
    .attr("transform", "translate(0," + height + ")")
    .call(d3.axisBottom(x)).selectAll("text").attr("font-size", 17).style("fill", "grey")

  // add x-label
  svg.append("text")
    .attr("text-anchor", "end")
    .attr("x", width/2 + 50)
    .attr("y", height + 50)
    .attr("font-size", 20)
    .style("fill", "grey")
    .text("Uhrzeit →");

  // add Days to yaxis
  svg.append("g")
    .call(d3.axisLeft(yName).tickSize(0))
    .selectAll("text").attr("font-size", 20).style("fill", "grey")
    .select(".domain").remove()

  // Add the shape to this svg!
  svg.append("g")
    .selectAll("myViolin")
    .data(sumstat)
    .enter()        // So now we are working group per group
    .append("g")
    .append("path") // append elemnt
      .attr("transform", d => ("translate(0, " + (y(parseInt(Object.keys(d)[0])))+")") ) // - verschiebung y axe
      .datum(d => Object.values(d)[0])     // So now we are working bin per bin
      .style("stroke", "none")
      .style("fill","grey")
      .attr("d", d3.area()
        .x(d => x(d.x0))
        .y0(d => yNum(-d.length)) // - => upper violin
        .y1(yNum(0)) // cuts half of the violin
        .curve(d3.curveCatmullRom)    // This makes the line smoother to give the violin appearance. Try d3.curveStep to see the difference
      )

  return svg.node();
}
# %% [html]

<div id="test_violin"></div>
# %%--- [javascript]
# properties:
#   run_on_load: true
# ---%%
removeAllChildren("test_violin");
RaincloudPlot(data)
# %%--- [javascript]
# properties:
#   top_hidden: true
#   bottom_hidden: true
#   run_on_load: true
# ---%%
var manager = {
  initData: data,
  currentFilters: {
    lor: undefined,
    graveness: undefined,
    involved: []
  },
  combinedIgnores: {},
  members: [], // list of objects that have a module and a an ignore property (explained in addMember())
  infoTextDiv: document.getElementById("infoText"),

  // updates all members with the new information
  trigger(info) {
    // merge the filters and the new info to create a new filter object, the new info
    // WILL OVERWRITE whatever the old filters were at the respective property!
    this.currentFilters = {...this.currentFilters, ...info}
    // we use this to prefilter the data to do less work later when filtering for every member separately
    const currentDataToFilterFurther = filterData(this.initData, {...this.currentFilters, ...this.combinedIgnores})
    console.log(`Number of currently filtered data points: ${filterData(this.initData, this.currentFilters).length}`)
    console.log(`Size of the prefiltered data: ${currentDataToFilterFurther.length}`)
    console.log("trigger called. updating all plots...")
    for (member of this.members) {
      const filteredData = filterData(currentDataToFilterFurther, {...this.currentFilters, ...member.ignore})
      if (!member.noUpdate) member.module.update(filteredData)
    }
    this.updateInfoText()
    console.log("Update finished.")
  },

  updateInfoText() {
    const f = this.currentFilters
    const area = f.lor === undefined ? "ganz Berlin" : lorNames[f.lor]
    const gs = f.graveness === undefined ? "Alle" : `${gravenessMeanings[f.graveness - 1]}e`
    let inv = ""
    if (f.involved.length > 0) {
      const category = involvedNames[f.involved[0]]
      if (category == "Sonstige") {
        inv = `mit Beteiligung <span style="color: #7f11e0">Sonstiger</span>`
      } else {
        inv = `mit <span style="color: #7f11e0">${category}</span>-Beteiligung`
      }
    }
    console.log(inv)
    const text = `<p style="font-size:20px; color:#000000; font-weight:bold;">
                  Momentan im Fokus: <br>
                  <span style="color: #2222ff">${gs}</span> Unfälle in <span style="color: #bb2727cc">${area}</span> <br>
                  ${inv}
                </p>`
    this.infoTextDiv.innerHTML = text
  },

  // add a module to be kept in the update loop to the members
  // ignoreFilter is a filter entity that is overwritten when updating the given module.
  // E.g. we dont want to lose all points outside of a state when selecting it
  // on the map. So the manager is told to ignore that filter just for the map module
  addMember(module, {
    ignoreFilter = {},
    noUpdate = false
  }) {
    // give the module a member 'manager', so it can
    // call module.manager.trigger(info)
    module.manager = this
    this.members.push({module: module, ignore: ignoreFilter, noUpdate: noUpdate});
    this.combinedIgnores = {...this.combinedIgnores, ...ignoreFilter}
  }
}

manager.addMember(moduleGravenessChart, { ignoreFilter: { graveness: undefined }, noUpdate: false}) // seems a little leaky
manager.addMember(moduleInvolvedChart, { ignoreFilter: { involved: [] }, noUpdate: false}) // seems leaky
manager.addMember(mapModule, {ignoreFilter: {lor: undefined}})
manager.updateInfoText()
# %% [javascript]
// Uncomment and execute to be able to reload the map
mapModule.map.remove()
# %%--- [css]
# properties:
#   top_hidden: true
# ---%%
/* We need this to make all cells wider */
:root {
  --cell-base-width: 1600px;
}

body {
  font-family: "Helvetica Neue", Helvetica, sans-serif;
  font-size: 14px;
  color: #333;
}

#main {
  height: 850px;
  width: 1600px;
  display: flex;
}

#map {
  background-color: white;
  width: 1100px;
}

#legend {
  position: absolute;
  height: 60px;
  width: 300px;
  top: 35px;
  left: 800px;
  /* Let mouse events go through to reach the map underneath */
  pointer-events: none;
  /* Make sure to be above the map pane (.leaflet-pane) */
  z-index: 450;
}

#right {
  background-color: lightgray;
  width: 30%;
}

#infoText {
  height: 10%;
  margin: 20px;
  text-align: center;
}

#gravenessDiagramm {
  height: 35%;
  margin: 20px;
}

#involvedDiagramm {
  height: 50%;
  margin: 20px;
}

/*
  This is needed, as chrome is drawing a rectangle around the focused polygon
  See: https://gis.stackexchange.com/questions/447502/prevent-leaflet-map-from-showing-rectangle-around-layer-on-click
*/
:focus {
  outline: -webkit-focus-ring-color auto 0px;
}

.leaflet-container .leaflet-marker-pane img, .leaflet-container .leaflet-shadow-pane img {
  background-color: #fff0;
}

.leaflet-popup-content h2 {
  font-size: 20px;
  text-decoration: underline;
}

/* Change colors of cluster bubbles */
.marker-cluster-large div {
  background-color: rgba(255, 0, 0, 0.8);
}
.marker-cluster-large  {
  background-color: rgba(255, 0, 0, 0.2);
}
.marker-cluster-medium div {
  background-color: rgba(255, 173, 0, 0.8);
}
.marker-cluster-medium  {
  background-color: rgba(255, 173, 0, 0.2);
}
.marker-cluster-small div {
  background-color: rgba(247, 255, 0, 0.8);
}
.marker-cluster-small  {
  background-color: rgba(247, 255, 0, 0.2);
}

/* Style of category legend text and circles */
.legend text {
  font-size: 0.8em;
  fill: black;
  font-family: sans-serif;
}

.legend circle {
  stroke: black;
  stroke-opacity: 0.5;
}