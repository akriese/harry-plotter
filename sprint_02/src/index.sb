# %% [esm]
import * as tj from "https://cdn.skypack.dev/pin/topojson@v3.0.2-ovpHjX420lx9YlKkg1QF/mode=imports/optimized/topojson.js"
import * as d3_ from "https://cdn.skypack.dev/d3@7.6.0"
import proj from 'https://cdn.skypack.dev/proj4'
import leaflet from 'https://cdn.skypack.dev/leaflet'
import leafletMarkercluster from 'https://cdn.skypack.dev/leaflet.markercluster';
export const topojson = tj;
export const d3 = d3_;
export const proj4 = proj;
export const L = leaflet;
export const Lm = leafletMarkercluster;
# %% [javascript]
async function fetchJson(url) {
  return fetch(url).then(response => response.json())
}

// LINREF coordinates in "ETRS89 / UTM zone 32N" (https://epsg.io/25832-1149)
var data = await fetchJson("https://raw.githubusercontent.com/akriese/harry-plotter/main/sprint_02/data/data_2021.json")

// district features https://tsb-opendata.s3.eu-central-1.amazonaws.com/lor_bezirksregionen_2021/lor_bezirksregionen_2021.geojson
// coordinates in "WGS 84 / UTM zone 33N" (https://epsg.io/32633)
// says https://www.stadtentwicklung.berlin.de/planen/basisdaten_stadtentwicklung/lor/de/download.shtml
var berlin_lor_topo = await fetchJson("https://raw.githubusercontent.com/akriese/harry-plotter/main/sprint_02/data/lor_bezirksregionen_2021.topojson")
berlin_lor_topo

# %% [javascript]
/// We define the two different coordinate systems for proj4
proj4.defs([["EPSG:32632","+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs +type=crs"],
           ["EPSG:32633", "+proj=utm +zone=33 +datum=WGS84 +units=m +no_defs +type=crs"],
           ["WGS84","+proj=longlat +datum=WGS84 +no_defs +type=crs"]]);
function from32to33(coords) {
  return proj4("EPSG:32632", "EPSG:32633", coords)
}

// ... and assign each data point a new parameter 'coords' holding x AND y value
// these coordinates now match the coordinates that are used by the topojson file :)
for (i in data) {
  data[i].coords = from32to33([data[i].LINREFX, data[i].LINREFY])
}
# %% [javascript]
// Precompute list of involved per accident
for (i in data) {
  var arr = []
  for (const [key, value] of Object.entries(data[i])) {
    if (key.startsWith("Ist") && value === true) {
      arr.push(key.replace("Ist", ""))
    }
  }
  data[i].Beteiligte = arr
}

# %% [javascript]
/// Collection of functions that grab certain parts of the given data

// general function to count occurences of a category in one data property
// property: name of the property to count in
// categories: list of categories whose counts in property get returned
function countCategoryOccurences(data, property, categories) {
  var counter = {}
  for (c of categories) {
    counter[c] = 0
  }

  const propArr = data.map(accident => accident[property])
  for (p of propArr) {
    counter[p]++
  }

  return counter
}

// count graveness
function countGraveness(data) {
  return countCategoryOccurences(data, "UKATEGORIE", [1, 2, 3])
}

// count accident types
function countAccidentTypes(data) {
  return countCategoryOccurences(data, "UTYP1", [1, 2, 3, 4, 5, 6, 7])
}

// we have to cut off the last two digits of each number, as we want the "Bezirksregionen"
// from https://www.statistik-berlin-brandenburg.de/raumbezuege#:~:text=Neue%20LOR%2DSystematik%20seit%202021
function countPerLOR(data) {
  var counts = {}
  data.forEach(d => {
    const lor = Math.floor(d.LOR_ab_2021 / 100)
    if (lor in counts) {
      counts[lor] += 1
    } else {
      counts[lor] = 1
    }
  })

  return counts
}

// extract accident time data
// mode: one of {"single", "array", "day_arrays"} defines how the data is returned
function getDaysAndHours(data, mode="single") {
  var filtered = data.map(accident => ({ day: accident.UWOCHENTAG, hour: accident.STUNDE }));
  if (mode === "single") return filtered;
  if (mode === "array" ) {
    return {
      day: filtered.map(acc => acc.day),
      hour: filtered.map(acc => acc.hour),
    }
  }

  // else: day_arrays
  var result = {}
  for (day of [1,2,3,4,5,6,7]) {
    result[day] = []
  }

  for (p of filtered) {
    result[p.day].push(p.hour)
  }

  return result
}

// get numbers of how many accidents had e.g. cars involved
function getInvolvedNumbers(data) {
  var involved = ["IstRad", "IstPKW", "IstFuss", "IstKrad", "IstGkfz", "IstSonstige"]
  var results = {}
  for (x of involved) {
    results[x] = 0
  }

  for (accident of data) {
    for (x of involved) {
      results[x] += accident[x] ? 1 : 0
    }
  }

  return results
}
# %% [javascript]
/// Apply a filter on the overall data and return the chosen set
function filterData(data, {
  lor = undefined, // int describing the focused lor; undefined means the whole city is focused
  days = [], // list of ints, representing week days of chosen accidents; empty list means no filter
  graveness = undefined, // int describing the chosen accidents with certain graveness (1,2,3); undefined means no filter
  involved = [] // list of strings, which kind parties are involved in an accident; empty means no filter
}) {
  return data.filter(
    accident => {
      if (lor !== undefined && accident.lor !== lor) {
        return false
      }

      if (days.length != 0 && days.indexOf(accident.UWOCHENTAG) == -1) {
        return false
      }

      if (graveness !== undefined && accident.UKATEGORIE != graveness) {
        return false
      }

      if (involved.length != 0) {
        var skip = false
        for (inv of involved) {
          if (!accident[inv]) {
            skip = true
            break
          }
        }

        // if some required entity is not involved, we continue
        if (skip) {
          return false
        }
      }

      return true
    }
  );
}
# %% [javascript]
// trying out the filter function
function measureFiltering(filter) {
  console.time()
  var result = filterData(data, filter)
  console.timeEnd()
  console.log(result.length)
  return result
}

measureFiltering({ graveness: 1 })
measureFiltering({ graveness: 2, involved: ["IstRad", "IstKrad"] })
measureFiltering({ graveness: 2, involved: ["IstRad"], days: [1,2,5,6] })
measureFiltering({ graveness: 2, days: [1,2,5,6] })
getInvolvedNumbers(measureFiltering({ graveness: 1, involved: ["IstRad"], days: [1,2,5,6] }))
getDaysAndHours(data, mode="day_arrays")

// trying out filters to precompute data for bar chart
getInvolvedNumbers(measureFiltering({involved: ["IstRad"]}))
countGraveness(data)
# %% [javascript]
// Berlin topographies
var LorAreas = topojson.feature(berlin_lor_topo, berlin_lor_topo.objects.states)

// creating an LOR topo object with WGS84 as coordinate system
var LorWGS = { type: "FeatureCollection"}
LorWGS.features = LorAreas.features.map(feature => ({
  type: "Feature",
  properties: feature.properties,
  geometry: {
    type: "Polygon",
    coordinates: [feature.geometry.coordinates[0].map(coords => {
      const [x, y] = proj4("EPSG:32633", "WGS84", coords)
      return [y, x];
    })]
  }
}))

// TODO: probably not needed anymore since we are now using leaflets polygon function
// statemesh should work as it looks like in the bubble map example
//statemesh = topojson.mesh(berlin_lor_topo, berlin_lor_topo.objects.states, (a, b) => a !== b)

var projection = d3.geoIdentity()
  .reflectY(true)
  .fitSize([1500, 1000], topojson.feature(berlin_lor_topo, berlin_lor_topo.objects.states))
# %% [html]
<!-- Main div for the map svg -->
<div id="content"></div>

<body>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=" crossorigin="" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
  <div id=mother></div>
</body>
# %%--- [css]
# properties:
#   top_hidden: true
# ---%%
body {
  font-family: "Helvetica Neue", Helvetica, sans-serif;
  font-size: 14px;
  color: #333;
}

#mother {
  height: 850px;
  width: 1000px
}

/*
  This is needed, as chrome is drawing a rectangle around the focused polygon
  See: https://gis.stackexchange.com/questions/447502/prevent-leaflet-map-from-showing-rectangle-around-layer-on-click
*/
:focus {
    outline: -webkit-focus-ring-color auto 0px;
}

.leaflet-container .leaflet-marker-pane img, .leaflet-container .leaflet-shadow-pane img {
  background-color: #fff0;
}

.leaflet-popup-content h2 {
  font-size: 20px;
  text-decoration: underline;
}

div.tooltip {
  position: absolute;
  text-align: center;
  width: fit-content;
  height: fit-content;
  padding: 2px;
  font: 12px sans-serif;
  background: lightsteelblue;
  border: 0px;
  border-radius: 8px;
  pointer-events: none;
}

/* Style of category legend text and circles */
.legend text {
  font-size: 0.8em;
  fill: black;
  font-family: sans-serif;
}

.legend circle {
  stroke: black;
  stroke-opacity: 0.5;
}
# %%--- [javascript]
# properties:
#   top_hidden: true
#   collapsed: true
# ---%%
colorLegend = (selection, props) => {
  const {
    colorScale,
    circleRadius,
    spacing,
    textOffset,
    backgroundRectWidth
  } = props;

  const backgroundRect = selection.selectAll('rect')
    .data([null]);
  const n = colorScale.domain().length;
  backgroundRect.enter().append('rect')
    .merge(backgroundRect)
      .attr('x', -circleRadius * 2)
      .attr('y', -circleRadius * 2)
      .attr('rx', circleRadius * 2)
      .attr('width', backgroundRectWidth)
      .attr('height', spacing * n + circleRadius * 2)
      .attr('fill', 'white')
      .attr('opacity', 0.8);

  const groups = selection.selectAll('.legend')
    .data(colorScale.domain());
  const groupsEnter = groups
    .enter().append('g')
      .attr('class', 'legend')
      .attr('category', d => d)
      .style("opacity", 0.8);
  groupsEnter
    .merge(groups)
      .attr('transform', (d, i) =>
        `translate(0, ${i * spacing})`
      )
      .attr("cursor", "pointer");
  groups.exit().remove();

  groupsEnter.append('circle')
    .merge(groups.select('circle'))
      .attr('r', circleRadius)
      .attr('fill', colorScale);

  groupsEnter.append('text')
    .merge(groups.select('text'))
      // cut off long category names
      .text(d => d.length > 29 ? d.substr(0, 27) + '...' : d)
      .attr('dy', '0.32em')
      .attr('x', textOffset);
}
# %% [javascript]
const monthNames = ["Januar", "Februar", "März", "April", "Mai", "Juni", "Juli",
                    "August", "September", "Oktober", "November", "Dezember"]
const dayNames = ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"]

function makeTooltipContent(accident) {
  const info = accident
  const persons = "<b>Beteiligte:</b> " + info.Beteiligte.join(", ")
  const dateTime = "<b>Monat/Tag/Uhrzeit:</b> " + monthNames[info.UMONAT - 1] +
                   "; " + dayNames[info.UWOCHENTAG - 1] +
                   "; " + info.USTUNDE + " Uhr";
  const gs = ["Tödlich", "Schwer", "Leicht"]
  const graveness = "<b>Schweregrad:</b> " + gs[info.UKATEGORIE - 1]
  const accidentTypes = ["Fahrunfall", "Abbiegeunfall", "Einbiegen / Kreuzen-Unfall",
                        "Überschreiten-Unfall", "Unfall durch ruhenden Verkehr",
                        "Unfall im Längsverkehr", "Sonstiger Unfall"]

    return "<b>" + accidentTypes[info.UTYP1 - 1] + "</b><br>"
               + dateTime + "<br>"
               + persons + "<br>"
               + graveness + "<br>";
}
# %% [javascript]
function StateColors(counts) {
  counts.dummy = 0
  const c = Object.entries(counts).map(([_, count]) => count)
  const [min, max] = [Math.min(...c), Math.max(...c)]
  const colorScale = d3.scaleSequential(d3.interpolateReds)

  const scaler = function(stateId) {
    return stateId in counts ? colorScale(counts[stateId] / max) : colorScale(counts.dummy / max)
  }

  return [scaler, [min, max]]
}

function LeafletAccidentMap(data, {
  topo,
  topoCoordSystem = "EPSG:32633",
  divName = "mother",
  minZoom = 11,
  maxZoom = 19,
  states, // FeatureCollection of topojson data
  stateTitle, // function to get the title from a state feature
  stateCount, // function to count the occurences per state in the data
  stateId, // function to get the ID of a given state
  tooltipContent, // function to create the content of a tooltip for the given datapoint
  dotCoords, // function to get the WGS84 (x, y) coordinates from a data point
  stateStrokeInactive = 0.0, // state border stroke thickness, while neither focused nor hovered over
  stateStrokeClicked = 3.0, // state border stroke thickness, while focused
  stateStrokeHover = 1.0, // state border stroke thickness, while hovered over
}) {
  // get topo bounds and convert them to WGS84, but with LatLong format (x and y switched)
  var bounds = topojson.bbox(topo)
  var boundsArr = [bounds.slice(0, 2), bounds.slice(2, 4)]
  var projBounds = [proj4(topoCoordSystem, "WGS84", boundsArr[0]).reverse(),
                    proj4(topoCoordSystem, "WGS84", boundsArr[1]).reverse()]

  const mod = { initBounds: projBounds, markersCluster: undefined }

  // draw map
  mod.map = L.map(divName, { doubleClickZoom: false }).fitBounds(projBounds);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    minZoom: minZoom,
    maxZoom: maxZoom,
  }).addTo(mod.map);

  // zoom out to see whole city
  mod.resetView = function() {
    this.map.fitBounds(this.initBounds)
    this.unfocusState(this.currentlyFocusedState)
    this.currentlyFocusedState = undefined
  }

  // reset border stroke when unfocussing a state
  mod.unfocusState = function(s) {
    if (s === undefined) return
    const res = this.states.find(p => stateTitle(p) === s)
    if (res !== undefined) res.setStyle({ weight: stateStrokeInactive })
  }

  mod.map.on("click", _event => mod.resetView())

  // create the LOR polygons and give them click behavior
  mod.states = states.features.map(f => {
    const polygon = L.polygon(f.geometry.coordinates[0],
            { stroke: true, color: "black", weight: stateStrokeInactive, fillOpacity: 0.8 })

    // change stroke when focussing state
    polygon.focus = function(e) {
      mod.map.fitBounds(this.getBounds())
      mod.unfocusState(mod.currentlyFocusedState)
      mod.currentlyFocusedState = stateTitle(f)
      this.setStyle({ weight: stateStrokeClicked })
      L.DomEvent.stopPropagation(e); // dont propagate click to map, otherwise mod.resetView() is called
    }

    polygon.isFocused = function() {
      return mod.currentlyFocusedState === stateTitle(f)
    }

    // ATTENTION: dblclick might also fire click twice, so dont do anything with different side effects in click!
    polygon
      .on("click", event => polygon.isFocused() ? mod.resetView() : polygon.focus(event))
      //.on("dblclick", _event => mod.resetView())
      // these functions implement the highlighting of states that are currently hovered over
      .on("mouseover", event => polygon.isFocused() ? {} : polygon.setStyle({ weight: stateStrokeHover }))
      .on("mouseout", event => polygon.isFocused() ? {} : polygon.setStyle({ weight: stateStrokeInactive }))
      .addTo(mod.map)

    polygon.properties = f.properties
    return polygon
  });

  mod.update = function(data) {
    // update polygon colors
    const counts = stateCount(data)
    const [colorScale, range] = StateColors(counts)
    this.states.forEach(p => {
      const id = stateId(p)
      p.setStyle({fillColor: colorScale(id)})
      p.bindTooltip(`${stateTitle(p)} (${counts[id]} Unfälle)`) // TODO: maybe handle case count == 1?
    })

    // TODO: when we get a color legend, update that too

    // remove marker cluster layer if existent
    if (this.markersCluster !== undefined) {
      this.map.removeLayer(this.markersCluster)
      delete this.markersCluster
    }

    // set accidentMarkers
    this.markersCluster = L.markerClusterGroup({ showCoverageOnHover: false });

    data.forEach(d => {
      const dot = L
        .marker(dotCoords(d).reverse())
        .bindTooltip(tooltipContent(d))
      this.markersCluster.addLayer(dot)
    })

    this.map.addLayer(this.markersCluster);
    return this
  }

  mod.update(data)

  return mod;
}
# %% [javascript]
var module = LeafletAccidentMap(data, {
  topo: berlin_lor_topo,
  states: LorWGS,
  dotCoords: d => ([d.XGCSWGS84, d.YGCSWGS84]),
  tooltipContent: acc => makeTooltipContent(acc),
  stateTitle: f => f.properties.BZR_NAME,
  stateCount: countPerLOR,
  stateId: p => parseInt(p.properties.BZR_ID),
})

// try out update, only show weekend accidents
//module.update(filterData(data, { days: [1,7] }))
# %% [javascript]
// Uncomment and execute to be able to reload the map
//module.map.remove()
# %% [javascript]
function removeAllChildren(name) {
  const div = document.getElementById(name);
  let child = div.lastElementChild;
  while (child !== null) {
    div.removeChild(child);
    child = div.lastElementChild;
  }
}
# %% [markdown]
### Sorted Bar chart category
# %% [html]
<div id="test"></div>

# %% [javascript]
removeAllChildren("test");
chart = BarChart(bar_data, {
  x: d => d.category, // x axis -> category
  y: d => d.count, // counts
  xDomain: d3.groupSort(bar_data, ([d]) => -d.count, d => d.category), // sort by descending frequency
  yLabel: "↑ Anzahl",
  width: 400,
  height: 200, // think about deceptive design
  //title: "Gesamtanzahl der Unfälle per Beteiligte",
})
# %% [javascript]
// Copyright 2021 Observable, Inc.
// Released under the ISC license.
// https://observablehq.com/@d3/bar-chart
function BarChart(data, {
  x = (d, i) => i, // given d in data, returns the (ordinal) x-value
  y = d => d, // given d in data, returns the (quantitative) y-value
  title, // given d in data, returns the title text
  marginTop = 20, // the top margin, in pixels
  marginRight = 0, // the right margin, in pixels
  marginBottom = 30, // the bottom margin, in pixels
  marginLeft = 40, // the left margin, in pixels
  width = 640, // the outer width of the chart, in pixels
  height = 400, // the outer height of the chart, in pixels
  xDomain, // an array of (ordinal) x-values
  xRange = [marginLeft, width - marginRight], // [left, right]
  yType = d3.scaleLinear, // y-scale type
  yDomain, // [ymin, ymax]
  yRange = [height - marginBottom, marginTop], // [bottom, top]
  xPadding = 0.1, // amount of x-range to reserve to separate bars
  yFormat, // a format specifier string for the y-axis
  yLabel, // a label for the y-axis
 // color = "currentColor" // bar fill color
} = {}) {
  // Compute values.
  const X = d3.map(data, x);
  const Y = d3.map(data, y);

  // Compute default domains, and unique the x-domain.
  if (xDomain === undefined) xDomain = X;
  if (yDomain === undefined) yDomain = [0, d3.max(Y)];
  xDomain = new d3.InternSet(xDomain);

  // Omit any data not present in the x-domain.
  const I = d3.range(X.length).filter(i => xDomain.has(X[i]));

  // Construct scales, axes, and formats.
  const xScale = d3.scaleBand(xDomain, xRange).padding(xPadding);
  const yScale = d3.scaleBand(yDomain, yRange);
  const xAxis = d3.axisBottom(xScale).tickSizeOuter(0);
  const yAxis = d3.axisLeft(yScale).ticks(height / 40, yFormat);
  // setted color can be changed by using another schemeCategory
  var color = d3.scaleOrdinal(data.map(d => d.category), d3.schemeCategory10).unknown("red");
  const col = d3.map(data, (d) => color(d.category));

  // Compute titles.
  //if (title === undefined) {
  //  const formatValue = yScale.tickFormat(100, yFormat);
  //  title = i => `${X[i]}\n${formatValue(Y[i])}`;
  //} else {
 //   const O = d3.map(data, d => d);
  //  const T = title;
  //  title = i => T(O[i], i, data);
  //}

  const svg = d3.select("#test").append("svg")
    .attr("width", width)
    .attr("height", height)
    .attr("viewBox", [0, 0, width, height])
    .attr("style", "max-width: 100%; height: auto; height: intrinsic;");

  svg.append("g")
      .attr("transform", `translate(${marginLeft},0)`)
      .call(yAxis)
      .call(g => g.select(".domain").remove())
      .call(g => g.selectAll(".tick line").clone()
          .attr("x2", width - marginLeft - marginRight)
          .attr("stroke-opacity", 0.1))
      .call(g => g.append("text")
          .attr("fill-opacity", 0.7)
          .attr("font-weight", "normal")
          .attr("x", -marginLeft)
          .attr("y", 10)
          .attr("fill", "currentColor")
          .attr("text-anchor", "start")
          .text(yLabel));

  const bar = svg.append("g")    
    .selectAll("rect")
    .data(I)
    .join("rect")
      .attr("x", i => xScale(X[i]))
      .attr("y", i => yScale(Y[i]))
      .attr("height", i => yScale(0) - yScale(Y[i]))
      .attr("width", xScale.bandwidth())
	  .attr("fill", i => col[i]);
  
  if (title) bar.append("title")
      .text(title);

  svg.append("g")
      .attr("transform", `translate(0,${height - marginBottom})`)
      .call(xAxis);

   svg.append("g")
      .attr("text-anchor", "end")
      .attr("font-family", "sans-serif")
      .attr("font-size", 10)
    .selectAll("text")
    .data(I)
    .join("text")
      .attr("text-anchor", i => X[i] < 0 ? "end" : "start")
      .attr("x", i => xScale(X[i]) + Math.sign(X[i] - 0) * 4)
      .attr("y", i => yScale(Y[i]) + yScale.bandwidth() / 2)
      .attr("dy", "0.35em")
      .text(i => format(X[i]));

  return svg.node();
}
# %% [javascript]
// helper functions to model data as needed
function get_data_object_bar_chart(data, number_fct) {
  categorys_counts = number_fct(data);
  entries = Object.entries(categorys_counts)
  let data_entry = entries.map(([key, val] = entry) => {
  		return {category: key, count: val};
	});
  return data_entry
}

// returns category without "Ist"
function get_substring(data_dict){
  data_dict.category = data_dict.category.substring(3);
}

// returns category with its meaning
function get_meaning(data_dict){
  cat_graveness_dict = {1: "Tote", 2: "Schwerverletzte", 3: "Leichtverletzte"};
  data_dict.category = cat_graveness_dict[data_dict.category];
}
# %% [javascript]
bar_data = get_data_object_bar_chart(data, getInvolvedNumbers);
bar_data.map(get_substring)
bar_data
# %% [markdown]
## sorted horizontal bar chart graveness
# %% [html]
<div id="test_horizontal"></div>
# %% [javascript]
removeAllChildren("test_horizontal");
chart = BarChartH(bar_data_horizontal, {
  x: d => d.count, // x axis -> counts
  y: d => d.category, // y-axis -> counts
  yDomain: d3.groupSort(bar_data_horizontal, ([d]) => d.count, d => d.category), // sort by descending frequency
  xLabel: "Anzahl →",
  width: 400,
  height: 200, // think about deceptive design
  marginLeft: 80,
  //title: "Gesamtanzahl der Unfälle per Beteiligte",
})
# %% [javascript]
cat_graveness_dict = {1: "Unfall mit Getöteten", 2: "Unfall mit Schwerverletzten", 3: "Unfall mit Leichtverletzten"};
bar_data_horizontal = get_data_object_bar_chart(data, countGraveness);
bar_data_horizontal.map(get_meaning)
bar_data_horizontal
# %% [javascript]
// Copyright 2021 Observable, Inc.
// Released under the ISC license.
// https://observablehq.com/@d3/horizontal-bar-chart
function BarChartH(data, {
  x = d => d, // given d in data, returns the (quantitative) x-value
  y = (d, i) => i, // given d in data, returns the (ordinal) y-value
  title, // given d in data, returns the title text
  marginTop = 30, // the top margin, in pixels
  marginRight = 0, // the right margin, in pixels
  marginBottom = 10, // the bottom margin, in pixels
  marginLeft = 50, // the left margin, in pixels
  width = 640, // the outer width of the chart, in pixels
  height, // outer height, in pixels
  xType = d3.scaleLinear, // type of x-scale
  xDomain, // [xmin, xmax]
  xRange = [marginLeft, width - marginRight], // [left, right]
  xFormat, // a format specifier string for the x-axis
  xLabel, // a label for the x-axis
  yPadding = 0.1, // amount of y-range to reserve to separate bars
  yDomain, // an array of (ordinal) y-values
  yRange, // [top, bottom]
  color = "currentColor", // bar fill color
  titleColor = "white", // title fill color when atop bar
  titleAltColor = "currentColor", // title fill color when atop background
} = {}) {
  // Compute values.
  const X = d3.map(data, x);
  const Y = d3.map(data, y);

  // Compute default domains, and unique the y-domain.
  if (xDomain === undefined) xDomain = [0, d3.max(X)];
  if (yDomain === undefined) yDomain = Y;
  yDomain = new d3.InternSet(yDomain);

  // Omit any data not present in the y-domain.
  const I = d3.range(X.length).filter(i => yDomain.has(Y[i]));

  // Compute the default height.
  if (height === undefined) height = Math.ceil((yDomain.size + yPadding) * 25) + marginTop + marginBottom;
  if (yRange === undefined) yRange = [marginTop, height - marginBottom];

  // Construct scales and axes.
  const xScale = xType(xDomain, xRange);
  const yScale = d3.scaleBand(yDomain, yRange).padding(yPadding);
  const xAxis = d3.axisTop(xScale).ticks(width / 80, xFormat);
  const yAxis = d3.axisLeft(yScale).tickSizeOuter(0);
  var color = d3.scaleOrdinal(data.map(d => d.category), ["red", "orange", "green"]).unknown("grey");
  const col = d3.map(data, (d) => color(d.category));

  // Compute titles.
  if (title === undefined) {
    const formatValue = xScale.tickFormat(100, xFormat);
    title = i => `${formatValue(X[i])}`;
  } else {
    const O = d3.map(data, d => d);
    const T = title;
    title = i => T(O[i], i, data);
  }

  const svg = d3.select("#test_horizontal").append("svg")
      .attr("width", width)
      .attr("height", height)
      .attr("viewBox", [0, 0, width, height])
      .attr("style", "max-width: 100%; height: auto; height: intrinsic;");

  svg.append("g")
      .attr("transform", `translate(0,${marginTop})`)
      .call(xAxis)
      .call(g => g.select(".domain").remove())
      .call(g => g.selectAll(".tick line").clone()
          .attr("y2", height - marginTop - marginBottom)
          .attr("stroke-opacity", 0.1))
      .call(g => g.append("text")
          .attr("x", width - marginRight)
          .attr("y", -22)
          .attr("fill", "currentColor")
          .attr("text-anchor", "end")
          .text(xLabel));

  svg.append("g") 
    .selectAll("rect")
    .data(I)
    .join("rect")
      .attr("x", xScale(0))
      .attr("y", i => yScale(Y[i]))
      .attr("width", i => xScale(X[i]) - xScale(0))
      .attr("height", yScale.bandwidth())
      .attr("fill", i => col[i]);

  svg.append("g")
      .attr("fill", titleColor)
      .attr("text-anchor", "end")
      .attr("font-family", "sans-serif")
      .attr("font-size", 10)
    .selectAll("text")
    .data(I)
    .join("text")
      .attr("x", i => xScale(X[i]))
      .attr("y", i => yScale(Y[i]) + yScale.bandwidth() / 2)
      .attr("dy", "0.35em")
      .attr("dx", -4)
      .text(title)
      .call(text => text.filter(i => xScale(X[i]) - xScale(0) < 20) // short bars
          .attr("dx", +4)
          .attr("fill", titleAltColor)
          .attr("text-anchor", "start"));

  svg.append("g")
      .attr("transform", `translate(${marginLeft},0)`)
      .call(yAxis);

  return svg.node();
}
# %% [markdown]
## Violin plot for amount of crash per days and hour

* https://d3-graph-gallery.com/graph/violin_jitter.html

\

# %% [javascript]
function hist_all_over(data, histogram) {
  sorted_data = data.slice().sort((a, b) => d3.ascending(a.UWOCHENTAG, b.UWOCHENTAG));
  data_grouped = d3.group(sorted_data,  d => d.UWOCHENTAG);
  bins = Array.from(data_grouped).map(d => d[1].map(d => d.USTUNDE)).map(histogram);
  return bins
};

categories = ["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"]
function swap_days_to_starting_at_monday(data){
  data.map(function(d){
  	d.UWOCHENTAG = categories[d.UWOCHENTAG - 1];
  });
  return data;
}
# %% [html]
<div id="test_violin"></div>
# %% [javascript]
removeAllChildren("test_violin");
RaincloudPlot(data)
# %% [javascript]
function RaincloudPlot(data) {
// Build and Show the Y scale

// set the dimensions and margins of the graph
var margin = {top: 20, right: 30, bottom: 10, left: 110},
    width = 1000 - margin.left - margin.right,
    height = 750; // - margin.top - margin.bottom;

var x = d3.scaleLinear()
  .domain([0, 24])          // Note that here the Y scale is set manually // days
  .range([0, width])
  
// Build and Show the X scale. It is a band scale like for a boxplot: each group has an dedicated RANGE on the axis. This range has a length of x.bandwidth
var y = d3.scaleBand()
  .range([0, height])
  .domain([1, 2, 3, 4, 5, 6, 7]) //days
  .padding(0)     // This is important: it is the space between 2 groups. 0 means no padding. 1 is the maximum.

categories = ["Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag", "Sonntag"]
// Create the Y axis for names
var yName = d3.scaleBand()
  .domain(categories)
  .range([0, height])
  .paddingInner(0)
  
// Features of the histogram
var histogram = d3.histogram()
      .domain(x.domain())
      .thresholds(x.ticks(24))    // Important: how many bins approx are going to be made? It is the 'resolution' of the violin plot
      .value(d => d)
  
// Compute the binning for each group of the dataset and shift Sunday to be day 7
var sumstat = hist_all_over(data, histogram);
sumstat.push(sumstat[0])
sumstat.shift()

// What is the biggest number of value in a bin? We need it cause this value will have a width of 100% of the bandwidth.
var maxNum = 0
for ( i in sumstat ){
  allBins = sumstat[i]
  lengths = allBins.map(function(a){return a.length;})
  longuest = d3.max(lengths)
  if (longuest > maxNum) { maxNum = longuest }
}

// adapt data structure inner array to dict
help_array = [1, 2, 3, 4, 5, 6, 7];
for ( i in sumstat ){
  var dict =  {};
  dict[help_array[i]] = sumstat[i];
  sumstat[i] = dict;
}

// The maximum width of a violin must be x.bandwidth = the width dedicated to a group
var yNum = d3.scaleLinear()
  .range([0, y.bandwidth()])
  .domain([-maxNum, maxNum])

// append the svg object to the body of the page
const svg = d3.select("#test_violin")
  .append("svg")
    .attr("width", width)// + margin.left + margin.right)
    .attr("height", height)// + margin.top + margin.bottom)
  	.attr("viewBox", [-80, 0, width + 200, height + 30])
    .attr("style", "max-width: 100%; height: auto; height: intrinsic;");
  
svg.append("g")
   .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

// add x-axis
svg.append("g")	
  .attr("transform", "translate(0," + height + ")") 
  .call(d3.axisBottom(x))

// add x-label 
svg.append("text")
      .attr("text-anchor", "end")
      .attr("x", width + 80)
      .attr("y", height + 5)
  	  .style("fill", "grey")
      .text("Uhrzeit →");

// add Days to yaxis 
svg.append("g")
  .call(d3.axisLeft(yName).tickSize(0))
  .select(".domain").remove()

// Add the shape to this svg!
svg.append("g")
.selectAll("myViolin")
.data(sumstat)
.enter()        // So now we are working group per group
.append("g")
  .append("path") // append elemnt
    .attr("transform", function(d){return("translate(0, " + (y(parseInt(Object.keys(d)[0])))+")")} ) // - verschiebung y axe
    .datum(function(d){return(Object.values(d)[0])})     // So now we are working bin per bin
    .style("stroke", "none")
    .style("fill","grey")
    .attr("d", d3.area()
        .x(function(d){return(x(d.x0)) })
        .y0(function(d){return yNum(-d.length)}) // - => upper violin
        .y1(yNum(0)) // cuts half of the violin
        .curve(d3.curveCatmullRom)    // This makes the line smoother to give the violin appearance. Try d3.curveStep to see the difference
    )

  return svg.node();
}